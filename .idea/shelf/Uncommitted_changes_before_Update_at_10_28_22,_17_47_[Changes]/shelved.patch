Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/Vector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drivetrain;\n\npublic class Vector {\n    private double [] vector;\n\n    public Vector(double [] vector){\n        this.vector = vector;\n    }\n\n    public Vector(Vector vector){\n        this.set(0, vector.get()[0]);\n        this.set(1, vector.get()[1]);\n    }\n\n    public double [] get(){\n        return this.vector;\n    }\n\n    public void set(int i, double num){\n        this.vector[i] = num;\n    }\n\n    public void set(Vector vector){\n        for(int i = 0; i < vector.get().length; i++){\n            this.set(i, vector.get()[i]);\n        }\n    }\n\n    public Vector neg(Vector vector){\n        for(double thisNum : vector.get()){\n            thisNum = -thisNum;\n        }\n\n        return this;\n    }\n\n    public Vector add(Vector vector){\n        if(vector.get().length == this.get().length){\n            for(int i = 0; i < vector.get().length; i++) {\n                this.set(i, this.get()[i] + vector.get()[i]);\n            }\n        }\n\n        return this;\n    }\n\n    public double dot(Vector vector){\n        int total = 0;\n\n        if(vector.get().length == this.get().length){\n            for(int i = 0; i < vector.get().length; i++){\n                total += this.get()[i] * vector.get()[i];\n            }\n        }\n\n        return total;\n    }\n\n    public Vector multiply(double coeff){\n        for(int i = 0; i < this.vector.length; i++){\n            this.set(i, this.vector[i] * coeff);\n        }\n\n        return this;\n    }\n\n    public double length(){\n        double length = 0.0;\n\n        for(double thisNum : this.get()){\n            length += thisNum * thisNum;\n        }\n\n        return (Math.sqrt(length));\n    }\n\n    public Vector normalize(){\n        double length = this.length();\n\n        for(int i = 0; i < this.get().length; i++){\n            this.set(i, this.get()[i] / length);\n        }\n\n        return this;\n    }\n\n    public Vector rotate(double angleChange){ // Radians\n        this.set(0, Math.cos(angleChange) * this.get()[0] - Math.sin(angleChange) * this.get()[1]);\n        this.set(1, Math.sin(angleChange) * this.get()[0] + Math.cos(angleChange) * this.get()[1]);\n\n        return this;\n    }\n\n    /*public Vector multiply(Matrix matrix){\n        double [] newVector = new double [this.get().length];\n\n        for(int i = 0; i < newVector.length; i++){\n            this.set(i, matrix.row(i).dot(this));\n        }\n\n        return this;\n    }*/\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/Vector.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/Vector.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/Vector.java	(revision d94891779ce4cf71a416a3b6fc6ad1cc2ed717d5)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/Vector.java	(date 1667004343776)
@@ -1,33 +1,33 @@
 package org.firstinspires.ftc.teamcode.drivetrain;
 
 public class Vector {
-    private double [] vector;
+    private double [] vectorArray;
 
     public Vector(double [] vector){
-        this.vector = vector;
+        this.vectorArray = vector;
     }
 
     public Vector(Vector vector){
-        this.set(0, vector.get()[0]);
-        this.set(1, vector.get()[1]);
+        this.set(0, vector.getVector()[0]);
+        this.set(1, vector.getVector()[1]);
     }
 
-    public double [] get(){
-        return this.vector;
+    public double [] getVector() {
+        return this.vectorArray;
     }
 
     public void set(int i, double num){
-        this.vector[i] = num;
+        this.vectorArray[i] = num;
     }
 
     public void set(Vector vector){
-        for(int i = 0; i < vector.get().length; i++){
-            this.set(i, vector.get()[i]);
+        for(int i = 0; i < vector.getVector().length; i++){
+            this.set(i, vector.getVector()[i]);
         }
     }
 
     public Vector neg(Vector vector){
-        for(double thisNum : vector.get()){
+        for(double thisNum : vector.getVector()){
             thisNum = -thisNum;
         }
 
@@ -35,9 +35,9 @@
     }
 
     public Vector add(Vector vector){
-        if(vector.get().length == this.get().length){
-            for(int i = 0; i < vector.get().length; i++) {
-                this.set(i, this.get()[i] + vector.get()[i]);
+        if(vector.getVector().length == this.getVector().length){
+            for(int i = 0; i < vector.getVector().length; i++) {
+                this.set(i, this.getVector()[i] + vector.getVector()[i]);
             }
         }
 
@@ -47,9 +47,9 @@
     public double dot(Vector vector){
         int total = 0;
 
-        if(vector.get().length == this.get().length){
-            for(int i = 0; i < vector.get().length; i++){
-                total += this.get()[i] * vector.get()[i];
+        if(vector.getVector().length == this.getVector().length){
+            for(int i = 0; i < vector.getVector().length; i++){
+                total += this.getVector()[i] * vector.getVector()[i];
             }
         }
 
@@ -57,8 +57,8 @@
     }
 
     public Vector multiply(double coeff){
-        for(int i = 0; i < this.vector.length; i++){
-            this.set(i, this.vector[i] * coeff);
+        for(int i = 0; i < this.vectorArray.length; i++){
+            this.set(i, this.vectorArray[i] * coeff);
         }
 
         return this;
@@ -67,7 +67,7 @@
     public double length(){
         double length = 0.0;
 
-        for(double thisNum : this.get()){
+        for(double thisNum : this.getVector()){
             length += thisNum * thisNum;
         }
 
@@ -77,22 +77,22 @@
     public Vector normalize(){
         double length = this.length();
 
-        for(int i = 0; i < this.get().length; i++){
-            this.set(i, this.get()[i] / length);
+        for(int i = 0; i < this.getVector().length; i++){
+            this.set(i, this.getVector()[i] / length);
         }
 
         return this;
     }
 
     public Vector rotate(double angleChange){ // Radians
-        this.set(0, Math.cos(angleChange) * this.get()[0] - Math.sin(angleChange) * this.get()[1]);
-        this.set(1, Math.sin(angleChange) * this.get()[0] + Math.cos(angleChange) * this.get()[1]);
+        this.set(0, Math.cos(angleChange) * this.getVector()[0] - Math.sin(angleChange) * this.getVector()[1]);
+        this.set(1, Math.sin(angleChange) * this.getVector()[0] + Math.cos(angleChange) * this.getVector()[1]);
 
         return this;
     }
 
     /*public Vector multiply(Matrix matrix){
-        double [] newVector = new double [this.get().length];
+        double [] newVector = new double [this.getVector().length];
 
         for(int i = 0; i < newVector.length; i++){
             this.set(i, matrix.row(i).dot(this));
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drivetrain;\n\nimport static org.firstinspires.ftc.teamcode.highlevel.Master.currentPosition;\nimport static org.firstinspires.ftc.teamcode.highlevel.Master.odometryAlg;\n\nimport com.qualcomm.hardware.bosch.BNO055IMU;\nimport com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\n\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\nimport org.firstinspires.ftc.teamcode.highlevel.Master.*;\nimport org.firstinspires.ftc.teamcode.Odometry.Odometry;\n//import org.firstinspires.ftc.teamcode.odometry.Odometry;\nimport static org.firstinspires.ftc.teamcode.highlevel.TeleOp1.*;\n\npublic class MecanumDrive {\n    public DcMotorEx FRMotor;\n    public DcMotorEx FLMotor;\n    public DcMotorEx BRMotor;\n    public DcMotorEx BLMotor;\n\n    Odometry odometry;\n\n    // Order for power values: FL, FR, RL, RR\n    // Make sure to normalize power values 0 to 1\n    public static final double [] NULL = {0.0, 0.0, 0.0, 0.0};\n\n    public static final double [] backwards = {-1.0, 1,0, -1.0, 1.0};\n    public Vector BACKWARDS = new Vector(backwards);\n\n    public static final double [] rightVector = {1.0, 1.0, -1.0, -1.0};\n    public Vector RIGHT = new Vector(rightVector);\n\n    public static final double [] turnRight = {-1.0, -1.0, -1.0, -1.0};\n    public Vector TURN_RIGHT = new Vector(turnRight);\n\n\n    // Navigation\n    public static final double [] NULL_POSITION = {0.0, 0.0};\n    public static final double [] DEFAULT_DIRECTION = {1.0, 0.0}; //Unit direction vector\n\n    public static final double MAX = 3.1416; //Max speed\n\n    private Vector position;\n    private Vector velocity;\n    private Vector drive;\n    private Vector displacement;\n\n    private Vector translation;\n    private Vector rotation;\n\n    int time;\n    double maxValue;\n\n    private BNO055IMU imu;\n\n    public MecanumDrive(HardwareMap hardwareMap) {\n//         Connect Motors\n        FRMotor = hardwareMap.get(DcMotorEx.class, \"FR\");\n        FLMotor = hardwareMap.get(DcMotorEx.class, \"FL\");\n        BRMotor = hardwareMap.get(DcMotorEx.class, \"BR\");\n        BLMotor = hardwareMap.get(DcMotorEx.class, \"BL\");\n\n        // Set Directions\n        FRMotor.setDirection(DcMotor.Direction.FORWARD);\n        FLMotor.setDirection(DcMotor.Direction.REVERSE);\n        BRMotor.setDirection(DcMotor.Direction.FORWARD);\n        BLMotor.setDirection(DcMotor.Direction.REVERSE);\n\n        // Set Motor Mode\n        FRMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        FLMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        BRMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        BLMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        FRMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        FLMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        BRMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        BLMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n        // Set Zero Power Behavior\n        FRMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        FLMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        BRMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        BLMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        // Stops Motors on INIT\n        FRMotor.setPower(0);\n        FLMotor.setPower(0);\n        BRMotor.setPower(0);\n        BLMotor.setPower(0);\n\n        //\n//        FRMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));\n//        FLMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));\n//        BRMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));\n//        BLMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));\n\n\n        velocity = new Vector(NULL_POSITION);\n        drive = new Vector(NULL);\n        displacement = new Vector(new double [] {0.0, 0.0});\n        translation = new Vector(NULL_POSITION);\n        rotation = new Vector(NULL_POSITION);\n\n        time = 0; // Ticks ig\n\n\n        //IMU\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n        parameters.angleUnit           = BNO055IMU.AngleUnit.DEGREES;\n        parameters.accelUnit           = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n        parameters.calibrationDataFile = \"BNO055IMUCalibration.json\";\n        parameters.loggingEnabled      = true;\n        parameters.loggingTag          = \"IMU\";\n        parameters.accelerationIntegrationAlgorithm = new JustLoggingAccelerationIntegrator();\n\n        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n        imu.initialize(parameters);\n    }\n\n    public void drive(double x, double y, double rotate) {\n        FRMotor.setPower(-x + y - rotate);\n        FLMotor.setPower( x + y + rotate);\n        BRMotor.setPower( x + y - rotate);\n        BLMotor.setPower(-x + y + rotate);\n    }\n\n    public void vectorDrive(double x, double y, double rotate, Telemetry telemetry) {\n        telemetry.addData(\"backwards[0]\", backwards[0]);\n        telemetry.addData(\"BACKWARDS.get()[0]\", BACKWARDS.get()[0]);\n//        telemetry.addData(\"rightVector[0]\", rightVector[0]);\n        telemetry.addData(\"RIGHT.get()[0\", RIGHT.get()[0]);\n        translation = BACKWARDS.multiply(y).add(RIGHT.multiply(x));\n        rotation = TURN_RIGHT.multiply(rotate);\n        drive = translation.add(rotation);\n\n        double maxValue = 0.0;\n        for(double thisNum : drive.get()){\n            if(Math.abs(thisNum) > maxValue){\n                maxValue = thisNum;\n            }\n        }\n\n        setPowers(drive.multiply(1.0 / maxValue), telemetry);\n\n        telemetry.addLine(\"Right: \" + (MAX * x));\n        telemetry.addLine(\"Forwards: \" + (MAX * -1 * -y));\n//        telemetry.addLine(position.get()[0] + \", \" + position.get()[1]);\n    }\n\n//    public void goToPosition(double targetXPosition, double targetYPosition, double power, double targetOrientation) {\n//        double distanceToXTarget = targetXPosition - odometry.getXCoordinate();\n//        double distanceToYTarget = targetYPosition - odometry.getYCoordinate();\n//\n//        double distance = Math.hypot(distanceToXTarget, distanceToYTarget);\n//\n//        while(FRMotor.isBusy() && FLMotor.isBusy() && BRMotor.isBusy() && BLMotor.isBusy()) {\n//            distanceToXTarget = targetXPosition - odometry.getXCoordinate();\n//            distanceToYTarget = targetYPosition - odometry.getYCoordinate();\n//\n//            double robotAngle = Math.toDegrees(Math.atan2(distanceToXTarget, distanceToYTarget));\n//\n//\n//        }\n//    }\n\n    public void fieldOrientatedDrive(double x, double y, double rotate, Telemetry telemetry) {\n        Orientation angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n        float pi = 3.1415926f;\n        float gyro_degrees = angles.firstAngle;\n        float gyro_radians = gyro_degrees * pi / 180;\n\n        y = -y;\n        double offAngle = 0;\n\n        if (x != 0) offAngle = Math.atan(y / x);\n\n        if (x <= 0){ // Getting displacement angle\n            offAngle = Math.PI - offAngle; // Might wanna use taylor series to approximate atan later since calculation times are gonna be annoying\n        }\n        double correctedX = Math.cos(-gyro_radians + offAngle);\n        double correctedY = Math.sin(-gyro_radians + offAngle);\n\n        correctedX = correctedX;\n        correctedY = -correctedY;\n\n        FRMotor.setPower(-correctedX + correctedY - rotate);\n        FLMotor.setPower( correctedX + correctedY + rotate);\n        BRMotor.setPower( correctedX + correctedY - rotate);\n        BLMotor.setPower(-correctedX + correctedY + rotate);\n\n        telemetry.addData(\"x2\", correctedX);\n        telemetry.addData(\"y2\", correctedY);\n        telemetry.addData(\"rotate\", rotate);\n        telemetry.addData(\"First Angle\", angles.firstAngle);\n    }\n\n//    public void driveTo(Vector target, Vector currentPosition){ // Probably run this every few ticks\n//        displacement = target.add(currentPosition.multiply(-1)); // Normalize this when inputting for ratios\n//\n//        drive = RIGHT.multiply(displacement.normalize().get()[0])\n//                .add(BACKWARDS.multiply(displacement.normalize().get()[1]));\n//\n//        setPowers(MOTORS, drive);\n//    }\n\n    public static double sensitivity = 5.0; // \"Steepness\" of gradient vectors\n    public Vector correct(){\n        odometryAlg.updateOrientationAndLocation();\n        displacement.set(0, -sensitivity * ((currentPosition.get()[0] % 23.50) - 11.75));\n        displacement.set(1, -sensitivity * ((currentPosition.get()[1] % 23.50) - 11.75));\n\n        return translation.add(displacement);\n    }\n\n//    public void driveTo(double currentX, double currentY, double targetX, double targetY){ // Probably run this every few ticks\n//        displacement.set(0, targetX - currentX);\n//        displacement.set(1, targetY - currentY);\n//\n//        drive = RIGHT.multiply(displacement.normalize().get()[0])\n//                .add(BACKWARDS.multiply(displacement.normalize().get()[1]));\n//\n//        setPowers(MOTORS, drive);\n//    }\n\n    @Deprecated\n    public static void setVelocities(DcMotorEx [] motors, Vector vector){\n        for(int i = 0; i < vector.get().length; i++){\n            motors[i].setVelocity(vector.get()[i] * MAX);\n        }\n    }\n\n    public void setPowers(Vector vector, Telemetry telemetry){\n//        for(int i = 0; i < motors.length; i++){\n//            motors[i].setPower(vector.get()[i]);\n//            telemetry.addData(\"powa\", vector.get()[i]);\n//        }\n\n        FLMotor.setPower(vector.get()[0]);\n        FRMotor.setPower(vector.get()[1]);\n        BLMotor.setPower(vector.get()[2]);\n        BRMotor.setPower(vector.get()[3]);\n        telemetry.addData(\"powa\", vector.get()[0]);\n    }\n\n    public void telemetry(Telemetry telemetry) {\n        telemetry.addData(\"FR Motor Position\", FRMotor.getCurrentPosition());\n        telemetry.addData(\"FL Motor Position\", FLMotor.getCurrentPosition());\n        telemetry.addData(\"BR Motor Position\", BRMotor.getCurrentPosition());\n        telemetry.addData(\"BL Motor Position\", BLMotor.getCurrentPosition());\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java	(revision d94891779ce4cf71a416a3b6fc6ad1cc2ed717d5)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java	(date 1667004343753)
@@ -134,15 +134,15 @@
 
     public void vectorDrive(double x, double y, double rotate, Telemetry telemetry) {
         telemetry.addData("backwards[0]", backwards[0]);
-        telemetry.addData("BACKWARDS.get()[0]", BACKWARDS.get()[0]);
+        telemetry.addData("BACKWARDS.getVector()[0]", BACKWARDS.getVector()[0]);
 //        telemetry.addData("rightVector[0]", rightVector[0]);
-        telemetry.addData("RIGHT.get()[0", RIGHT.get()[0]);
+        telemetry.addData("RIGHT.getVector()[0", RIGHT.getVector()[0]);
         translation = BACKWARDS.multiply(y).add(RIGHT.multiply(x));
         rotation = TURN_RIGHT.multiply(rotate);
         drive = translation.add(rotation);
 
         double maxValue = 0.0;
-        for(double thisNum : drive.get()){
+        for(double thisNum : drive.getVector()){
             if(Math.abs(thisNum) > maxValue){
                 maxValue = thisNum;
             }
@@ -152,7 +152,7 @@
 
         telemetry.addLine("Right: " + (MAX * x));
         telemetry.addLine("Forwards: " + (MAX * -1 * -y));
-//        telemetry.addLine(position.get()[0] + ", " + position.get()[1]);
+//        telemetry.addLine(position.getVector()[0] + ", " + position.getVector()[1]);
     }
 
 //    public void goToPosition(double targetXPosition, double targetYPosition, double power, double targetOrientation) {
@@ -205,8 +205,8 @@
 //    public void driveTo(Vector target, Vector currentPosition){ // Probably run this every few ticks
 //        displacement = target.add(currentPosition.multiply(-1)); // Normalize this when inputting for ratios
 //
-//        drive = RIGHT.multiply(displacement.normalize().get()[0])
-//                .add(BACKWARDS.multiply(displacement.normalize().get()[1]));
+//        drive = RIGHT.multiply(displacement.normalize().getVector()[0])
+//                .add(BACKWARDS.multiply(displacement.normalize().getVector()[1]));
 //
 //        setPowers(MOTORS, drive);
 //    }
@@ -214,8 +214,8 @@
     public static double sensitivity = 5.0; // "Steepness" of gradient vectors
     public Vector correct(){
         odometryAlg.updateOrientationAndLocation();
-        displacement.set(0, -sensitivity * ((currentPosition.get()[0] % 23.50) - 11.75));
-        displacement.set(1, -sensitivity * ((currentPosition.get()[1] % 23.50) - 11.75));
+        displacement.set(0, -sensitivity * ((currentPosition.getVector()[0] % 23.50) - 11.75));
+        displacement.set(1, -sensitivity * ((currentPosition.getVector()[1] % 23.50) - 11.75));
 
         return translation.add(displacement);
     }
@@ -224,30 +224,30 @@
 //        displacement.set(0, targetX - currentX);
 //        displacement.set(1, targetY - currentY);
 //
-//        drive = RIGHT.multiply(displacement.normalize().get()[0])
-//                .add(BACKWARDS.multiply(displacement.normalize().get()[1]));
+//        drive = RIGHT.multiply(displacement.normalize().getVector()[0])
+//                .add(BACKWARDS.multiply(displacement.normalize().getVector()[1]));
 //
 //        setPowers(MOTORS, drive);
 //    }
 
     @Deprecated
     public static void setVelocities(DcMotorEx [] motors, Vector vector){
-        for(int i = 0; i < vector.get().length; i++){
-            motors[i].setVelocity(vector.get()[i] * MAX);
+        for(int i = 0; i < vector.getVector().length; i++){
+            motors[i].setVelocity(vector.getVector()[i] * MAX);
         }
     }
 
     public void setPowers(Vector vector, Telemetry telemetry){
 //        for(int i = 0; i < motors.length; i++){
-//            motors[i].setPower(vector.get()[i]);
-//            telemetry.addData("powa", vector.get()[i]);
+//            motors[i].setPower(vector.getVector()[i]);
+//            telemetry.addData("powa", vector.getVector()[i]);
 //        }
 
-        FLMotor.setPower(vector.get()[0]);
-        FRMotor.setPower(vector.get()[1]);
-        BLMotor.setPower(vector.get()[2]);
-        BRMotor.setPower(vector.get()[3]);
-        telemetry.addData("powa", vector.get()[0]);
+        FLMotor.setPower(vector.getVector()[0]);
+        FRMotor.setPower(vector.getVector()[1]);
+        BLMotor.setPower(vector.getVector()[2]);
+        BRMotor.setPower(vector.getVector()[3]);
+        telemetry.addData("powa", vector.getVector()[0]);
     }
 
     public void telemetry(Telemetry telemetry) {
