Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/odometry/TestingOdometryAlgorithm.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.odometry;\n\n// Auxillary\nimport org.firstinspires.ftc.teamcode.drivetrain.*;\nimport org.firstinspires.ftc.teamcode.highlevel.*;\n\n// Encoders\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\n\npublic class TestingOdometryAlgorithm extends Master {\n    HardwareMap hardwareMap;\n\n    DcMotor encoder1;\n    DcMotor encoder2;\n    DcMotor encoder3;\n    // Use encoder objects encoder1, encorder2, encoder3 from Master\n    // Encoder wheels are placed as follows:\n    //    ________\n    //   |   ==   |\n    //   ||       |\n    //   |   ==   | encoder 1 on top, encoder 2 on bottom, encoder3 on left\n    //    ˜˜˜˜˜˜˜˜\n\n    // Chassis dimensional constants\n    public static final double TRACK_WIDTH = 10.0; // Distance between dead wheels 1 and 2 in inches\n    public static final double DISTANCE_TO_BACK_WHEEL = 4.0; // Distance between center of robot (currentPosition) and back dead wheel - again, in inches\n    public static final double DEAD_WHEEL_RADIUS = 1.5;\n    public static final double TICKS_PER_ROTATION = 8192;\n\n    // Input / Output, calculations\n    public static final double [] DEFAULT_STARTING_ORIENTATION = {0.0, 1.0};\n    public static final double [] DEFAULT_STARTING_NORMAL_VECTOR = {-1.0, 0.0};\n    public double orientationAngle = Math.PI / 2; // Front-facing angle relative to horizontal at start\n    public double angleChange;\n    public static final double WHEEL_TRAVEL_CONVERSION_FOR_DEAD_WHEELS = Math.PI * 2 * DEAD_WHEEL_RADIUS / TICKS_PER_ROTATION;\n\n    // Encoder deltas in ticks!\n    private double encoder1Delta;\n    private double encoder2Delta;\n    private double encoder3Delta;\n\n    // Constructor to start everything\n    public void initTestingOdometryAlgorithm(Vector startingPosition) {\n        // Encoders\n        encoder1 = hardwaremap.get(DcMotorEx.class, \"encoder1\");\n        encoder2 = hardwaremap.get(DcMotorEx.class, \"encoder2\");\n        encoder3 = hardwareMap.get(DcMotorEx.class, \"encoder3\");\n\n        encoder1.setDirection(DcMotor.Direction.REVERSE);\n        encoder2.setDirection(DcMotor.Direction.REVERSE);\n        encoder3.setDirection(DcMotor.Direction.FORWARD);\n\n        encoder1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        encoder2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        encoder3.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n        encoder1Reading = encoder1.getCurrentPosition();\n        encoder2Reading = encoder2.getCurrentPosition();\n        encoder3Reading = encoder3.getCurrentPosition();\n\n        encoder1Delta = 0.0;\n        encoder2Delta = 0.0;\n        encoder3Delta = 0.0;\n\n        angleChange = 0.0;\n\n        // Vector initialization\n        currentPosition = STARTING_POSITION;\n        travel = new Vector(DEFAULT_STARTING_ORIENTATION);\n        orientation = new Vector(DEFAULT_STARTING_ORIENTATION);\n        normalOrientation = new Vector(DEFAULT_STARTING_NORMAL_VECTOR);\n\n    }\n\n    public void updateOrientationAndLocation(){\n        // Conversion to inches\n        encoder1Delta = (encoder1.getCurrentPosition() - encoder1Reading) * WHEEL_TRAVEL_CONVERSION_FOR_DEAD_WHEELS;\n        encoder2Delta = (encoder2.getCurrentPosition() - encoder2Reading) * WHEEL_TRAVEL_CONVERSION_FOR_DEAD_WHEELS;\n        encoder3Delta = (encoder3.getCurrentPosition() - encoder3Reading) * WHEEL_TRAVEL_CONVERSION_FOR_DEAD_WHEELS;\n\n        // Tick-updting encoder positions\n        encoder1Reading = encoder1.getCurrentPosition();\n        encoder2Reading = encoder2.getCurrentPosition();\n        encoder3Reading = encoder3.getCurrentPosition();\n\n        // Sandwhich algorithm in 1/2 tick-updating calls for the sake of accuracy\n        angleChange = (encoder1Delta - encoder2Delta) / TRACK_WIDTH;\n\n        orientationAngle += angleChange / 2;\n        orientation.rotate(angleChange / 2);\n        normalOrientation.rotate(angleChange / 2);\n\n        travel = orientation.multiply(0.5 * encoder1Delta + 0.5 * encoder2Delta).add\n                (normalOrientation.multiply(encoder3Delta * Math.cos(orientationAngle) - encoder3Delta * (angleChange / 2)));\n\n        orientationAngle += angleChange / 2;\n        orientation.rotate(angleChange / 2);\n        normalOrientation.rotate(angleChange / 2);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/odometry/TestingOdometryAlgorithm.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/odometry/TestingOdometryAlgorithm.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/odometry/TestingOdometryAlgorithm.java	(revision 2be55ab5b12b22c403d0b64863796427ca84192b)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/odometry/TestingOdometryAlgorithm.java	(date 1666827568901)
@@ -10,12 +10,7 @@
 import com.qualcomm.robotcore.hardware.HardwareMap;
 
 public class TestingOdometryAlgorithm extends Master {
-    HardwareMap hardwareMap;
-
-    DcMotor encoder1;
-    DcMotor encoder2;
-    DcMotor encoder3;
-    // Use encoder objects encoder1, encorder2, encoder3 from Master
+    // Use encoder objects encoder1, encorder2, encoder3 from AuxillaryData
     // Encoder wheels are placed as follows:
     //    ________
     //   |   ==   |
@@ -30,6 +25,8 @@
     public static final double TICKS_PER_ROTATION = 8192;
 
     // Input / Output, calculations
+    Vector orientation;
+    Vector normalOrientation;
     public static final double [] DEFAULT_STARTING_ORIENTATION = {0.0, 1.0};
     public static final double [] DEFAULT_STARTING_NORMAL_VECTOR = {-1.0, 0.0};
     public double orientationAngle = Math.PI / 2; // Front-facing angle relative to horizontal at start
@@ -41,12 +38,13 @@
     private double encoder2Delta;
     private double encoder3Delta;
 
+
     // Constructor to start everything
-    public void initTestingOdometryAlgorithm(Vector startingPosition) {
+    public TestingOdometryAlgorithm(Vector startingPosition) {
         // Encoders
         encoder1 = hardwaremap.get(DcMotorEx.class, "encoder1");
         encoder2 = hardwaremap.get(DcMotorEx.class, "encoder2");
-        encoder3 = hardwareMap.get(DcMotorEx.class, "encoder3");
+        encoder3 = hardwaremap.get(DcMotorEx.class, "encoder3");
 
         encoder1.setDirection(DcMotor.Direction.REVERSE);
         encoder2.setDirection(DcMotor.Direction.REVERSE);
@@ -98,5 +96,7 @@
         orientationAngle += angleChange / 2;
         orientation.rotate(angleChange / 2);
         normalOrientation.rotate(angleChange / 2);
+
+        Master.currentPosition.add(travel);
     }
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/Turntable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.manipulator;\n\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\n\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\n\npublic class Turntable {\n    private DcMotorEx tableMotor;\n\n    public Turntable(HardwareMap hardwareMap) {\n        tableMotor = hardwareMap.get(DcMotorEx.class, \"linear_motor\"); // connect motor\n\n        tableMotor.setDirection(DcMotor.Direction.FORWARD); // set direction\n        //tableMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); // set motor mode\n        //tableMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        tableMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE); // set zero power behavior\n\n        tableMotor.setPower(0);\n    }\n\n    public void turn(double power) {\n        tableMotor.setPower(power);\n    }\n\n    public void telemetry(Telemetry telemetry) {\n        telemetry.addData(\"Carousel Power\", tableMotor.getPower());\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/Turntable.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/Turntable.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/Turntable.java	(revision 2be55ab5b12b22c403d0b64863796427ca84192b)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/Turntable.java	(date 1666828093533)
@@ -1,5 +1,6 @@
 package org.firstinspires.ftc.teamcode.manipulator;
 
+import static org.firstinspires.ftc.teamcode.highlevel.Master.hardwaremap;
 import com.qualcomm.robotcore.hardware.DcMotor;
 import com.qualcomm.robotcore.hardware.DcMotorEx;
 import com.qualcomm.robotcore.hardware.HardwareMap;
@@ -7,24 +8,76 @@
 import org.firstinspires.ftc.robotcore.external.Telemetry;
 
 public class Turntable {
-    private DcMotorEx tableMotor;
+    // Make sure that motor starts at 0 ticks
+    public static DcMotorEx tableMotor; // Add this to Master
+    private static final double TURNTABLE_RATIO = 0.16; // Ratio for angle change
+    private static final double TURNTABLE_MOTOR_GEARING =  (double) 1 / 60; // Inherent gearing for turntable motor
+    private static final double OVERALL_RATIO = TURNTABLE_RATIO * TURNTABLE_MOTOR_GEARING;
+
+    // Auxillary variables, add these to Master
+    public static double turntableAngle; // Radians, as always
 
-    public Turntable(HardwareMap hardwareMap) {
-        tableMotor = hardwareMap.get(DcMotorEx.class, "linear_motor"); // connect motor
+    // Internal use variables
+    private int neededTicks; // Displacement or target position
+
+    public Turntable() {
+        tableMotor = hardwaremap.get(DcMotorEx.class, "Turntable Motor"); // connect motor
 
         tableMotor.setDirection(DcMotor.Direction.FORWARD); // set direction
-        //tableMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); // set motor mode
-        //tableMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
+        tableMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); // set motor mode
+        tableMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER); // Run to position?
         tableMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE); // set zero power behavior
 
-        tableMotor.setPower(0);
+        turntableAngle = 0.0;
+        neededTicks = 0;
+    }
+
+    public void turnTo(double angle){ // Turntable angle
+        turntableAngle = tableMotor.getCurrentPosition() * OVERALL_RATIO;
+        neededTicks = (int) (angle / OVERALL_RATIO);
+
+        tableMotor.setTargetPosition(neededTicks);
+        if(tableMotor.getTargetPosition() < tableMotor.getCurrentPosition()){ // Note that this is geared, directions will look reversed
+            tableMotor.setPower(1.0);// Stable enough for max torque?
+        }else{
+            tableMotor.setPower(-1.0);
+        }
     }
 
+    public void turnBy(double angleChange){ // Turntable angle
+        turntableAngle = tableMotor.getCurrentPosition() * OVERALL_RATIO;
+        neededTicks = (int) (angleChange / OVERALL_RATIO);
+
+        tableMotor.setTargetPosition(neededTicks + tableMotor.getCurrentPosition());
+        if(tableMotor.getTargetPosition() < tableMotor.getCurrentPosition()){ // Note that this is geared, directions will look reversed
+            tableMotor.setPower(1.0);// Stable enough for max torque?
+        }else{
+            tableMotor.setPower(-1.0);
+        }
+    }
+
+    public void reset(){ // Don't tangle the wires lol, run this intermittently
+        tableMotor.setTargetPosition(0);
+        if(tableMotor.getCurrentPosition() < 0){
+            tableMotor.setPower(-1.0); // Directions reversed due to gearing
+        }else{
+            tableMotor.setPower(1.0);
+        }
+    }
+
+    @Override
+    public String toString(){
+        return String.format("Turntable motor position: %d\nTurntable angle from horizontal: %03.2f\nMotor power %2.1f", tableMotor.getCurrentPosition(), turntableAngle, tableMotor.getPower());
+    }
+
+    @Deprecated
     public void turn(double power) {
         tableMotor.setPower(power);
     }
 
+    @Deprecated
     public void telemetry(Telemetry telemetry) {
         telemetry.addData("Carousel Power", tableMotor.getPower());
     }
+
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/LinearSlides.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.manipulator;\n\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.hardware.Servo;\n\n\n\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\n// This comment was pushed\npublic class LinearSlides {\n    private DcMotorEx linearMotor;\n    private int motorStartPosition;\n\n    public LinearSlides(HardwareMap hardwareMap) {\n        linearMotor = hardwareMap.get(DcMotorEx.class, \"linear_motor\"); // connect motor\n        motorStartPosition = linearMotor.getCurrentPosition();\n\n        linearMotor.setDirection(DcMotor.Direction.FORWARD); // set direction\n        //linearMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); // set motor mode\n        //linearMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        linearMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE); // set zero power behavior\n\n        linearMotor.setPower(0);\n    }\n\n    public void raise(int targetPosition) {\n        linearMotor.setTargetPosition(targetPosition + motorStartPosition);\n        linearMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        linearMotor.setPower(1.0);\n    }\n\n    public void lower() {\n        linearMotor.setTargetPosition(motorStartPosition);\n        linearMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        linearMotor.setPower(1.0);\n    }\n\n    public void telemetry(Telemetry telemetry) {\n        telemetry.addData(\"Lift Motor Current\", linearMotor.getCurrentPosition());\n        telemetry.addData(\"Lift Motor Target\", linearMotor.getTargetPosition());\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/LinearSlides.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/LinearSlides.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/LinearSlides.java	(revision 2be55ab5b12b22c403d0b64863796427ca84192b)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/LinearSlides.java	(date 1666828015965)
@@ -1,44 +1,132 @@
 package org.firstinspires.ftc.teamcode.manipulator;
 
-import com.qualcomm.robotcore.hardware.DcMotor;
 import com.qualcomm.robotcore.hardware.DcMotorEx;
 import com.qualcomm.robotcore.hardware.HardwareMap;
-import com.qualcomm.robotcore.hardware.Servo;
-
-
-
 import org.firstinspires.ftc.robotcore.external.Telemetry;
-// This comment was pushed
+import org.firstinspires.ftc.teamcode.drivetrain.*;
+import java.math.*;
+import com.qualcomm.robotcore.hardware.DcMotor;
+import org.firstinspires.ftc.teamcode.highlevel.Master;
+
+import static org.firstinspires.ftc.teamcode.highlevel.Master.invSqrt;
+import static org.firstinspires.ftc.teamcode.highlevel.Master.turntable;
+import static org.firstinspires.ftc.teamcode.manipulator.Turntable.turntableAngle; // Remove this in final version
+
+// This comment was pushed today
 public class LinearSlides {
-    private DcMotorEx linearMotor;
-    private int motorStartPosition;
+    // Add all of these to Master
+    public static DcMotorEx seeSawMotor;
+    public static DcMotorEx extensionMotor;
+    public static Vector manipulatorPosition;
+    private static HardwareMap hardwareMap;
+    public static double seesawAngle;
+    public static double seesawExtensionLength;
+
+    // Internal use variables
+    private static double [] displacement;
+    private static double angleDisplacement;
+    private static double ticksDisplacement;
 
-    public LinearSlides(HardwareMap hardwareMap) {
-        linearMotor = hardwareMap.get(DcMotorEx.class, "linear_motor"); // connect motor
-        motorStartPosition = linearMotor.getCurrentPosition();
+    // Manipulator specifications in inches, radians
+    public static final double ROOT_HEIGHT = 8.0; // From ground to linear slide mount
+    private static final double STARTING_EXTENDER_LENGTH = 9.0; // Starting length from pivot axle
+    // Rotation
+    private static final double SEESAW_MOTOR_RATIO = 60; // 60:1 or 40:1 motor?
+    private static final double SEESAW_OVERALL_RATIO = 2 * Math.PI * (30 / 64) / (4096 * SEESAW_MOTOR_RATIO); // Angle per tick
+    private static final double STARTING_ANGLE = 0.0;// Of the Manipulator, factor in end-effector's center (cone center), in inches
+    // Extension
+    private static final double EXTENDER_MOTOR_RATIO = 20; // 20:1 or 40:1 motor?
+    private static final double PULLEY_RADIUS = 1.0; // Radius of pulley interacting with string
+    private static final double EXTENDER_OVERALL_RATIO = 2 * Math.PI / (4096 * EXTENDER_MOTOR_RATIO); // Inches per tick
 
-        linearMotor.setDirection(DcMotor.Direction.FORWARD); // set direction
-        //linearMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); // set motor mode
-        //linearMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
-        linearMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE); // set zero power behavior
+    /* Manipulator diagram:
 
-        linearMotor.setPower(0);
+            ==/\=============== <- Length from center of pivot w/ extension
+              ||                <- Root
+          ____||____            <- Turntable
+
+
+     Extension Mechanism:
+           _     ________ <- Secondary section
+        ==/o\========     <- Primary section
+
+     1. String from extension motor to end of manipulator, longer when retracted
+     2. Surgical tubing between end and pivot of manipulator to bias manipulator towards retracted
+     3. Pull string to extend, roll back to retract
+     */
+
+    public LinearSlides(){
+        seeSawMotor = hardwareMap.get(DcMotorEx.class, "Seesaw Motor");
+        extensionMotor = hardwareMap.get(DcMotorEx.class, "Linear Slide Extension Motor");
+
+        seeSawMotor.setDirection(DcMotor.Direction.FORWARD); // set direction, this was made for 1 gear transfer from drive to axle
+        seeSawMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); // set motor mode
+        seeSawMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER); // Run to position?
+        seeSawMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE); // set zero power behavior
+
+        // Extension Motor specifics need to be edited ig
+        extensionMotor.setDirection(DcMotor.Direction.FORWARD); // set direction, probably need to change
+        extensionMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); // set motor mode
+        extensionMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER); // Run to position?
+        extensionMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE); // set zero power behavior
+
+        // Motor kinematics ;)
+        // Note: initialize turntable before manipulator!!!
+        manipulatorPosition = new Vector(new double [] {0.0, 0.0, 0.0}); // Idk if this works lol
+
+        manipulatorPosition.set(0, (STARTING_EXTENDER_LENGTH) * Math.cos(turntableAngle) * Math.cos(STARTING_ANGLE));
+        manipulatorPosition.set(1, (STARTING_EXTENDER_LENGTH) * Math.sin(turntableAngle) * Math.cos(STARTING_ANGLE));
+        manipulatorPosition.set(2, ROOT_HEIGHT + (STARTING_EXTENDER_LENGTH * Math.sin(STARTING_ANGLE)));
+
+        displacement = new double[2];
+        angleDisplacement = 0.0;
+        ticksDisplacement = 0.0;
+    }
+
+    public void goPointAt(double [] xyzDisplacement){ // Make sure to input 3-array for targeted scoring position!!!!!!!! Will have to get angle of robot once it gets to junction, then correct a second time. This is not a one-time algorithm!!!
+        // Actually does everything at the same time, will need to edit based on extension speed (want to minimize extended time for reliability purposes)
+        displacement = xyzDisplacement; // Screw it I don't wanna run the method over and over haha
+//  Note: displacement from pivot point of linear slide
+        // Move turntable, note that this will turn the turntable 180˚ back if target is behind the pivot, will need to account for ability to swing beyond 90˚ vertical (behind) later
+        if(displacement[0] <= 0){ // Getting displacement angle
+            angleDisplacement = Math.PI - Math.atan(displacement[1] / displacement[0]); // Might wanna use taylor series to approximate atan later since calculation times are gonna be annoying
+        }else{
+            angleDisplacement = Math.atan(displacement[1] / displacement[0]);
+        }
+        turntable.turnTo(angleDisplacement);
+
+        // Pivot seesaw up / down to desired position. Due to the behavior described in the previous step, this step (for now) doesn't have to account for swinging beyond 90˚ vertical
+        /*
+          /|
+         / |
+        /\_| <- Angle
+         */
+        this.pivotTo(Math.atan(displacement[3] / invSqrt(displacement[0]*displacement[0] + displacement[1]*displacement[1])));
+
+        // Extend
+        this.extendTo(Math.sqrt(displacement[0]*displacement[0] + displacement[1]*displacement[1] + displacement[2]*displacement[2]));
     }
 
-    public void raise(int targetPosition) {
-        linearMotor.setTargetPosition(targetPosition + motorStartPosition);
-        linearMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
-        linearMotor.setPower(1.0);
+    public void extendTo(double target){ // Inches
+        extensionMotor.setTargetPosition((int) ((target - STARTING_EXTENDER_LENGTH) / EXTENDER_OVERALL_RATIO));
+        if(extensionMotor.getTargetPosition() < extensionMotor.getCurrentPosition()){
+            extensionMotor.setPower(-1.0);
+        }else{
+            extensionMotor.setPower(1.0);
+        }
     }
 
-    public void lower() {
-        linearMotor.setTargetPosition(motorStartPosition);
-        linearMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
-        linearMotor.setPower(1.0);
+    public void pivotTo(double targetAngle){ // Radians
+        seeSawMotor.setTargetPosition((int) (targetAngle / SEESAW_OVERALL_RATIO));
+        if(seeSawMotor.getTargetPosition() < seeSawMotor.getCurrentPosition()){ // Remember, motor is geared so direction reversed
+            seeSawMotor.setPower(1.0); // To go down, set power to negative, might have to reverse this based on motor packaging
+        }else{
+            seeSawMotor.setPower(-1.0);
+        }
     }
 
-    public void telemetry(Telemetry telemetry) {
-        telemetry.addData("Lift Motor Current", linearMotor.getCurrentPosition());
-        telemetry.addData("Lift Motor Target", linearMotor.getTargetPosition());
+    public void update(){ // Run this as much as applicable
+        seesawExtensionLength = (seeSawMotor.getCurrentPosition() * EXTENDER_OVERALL_RATIO) - STARTING_EXTENDER_LENGTH;
+        seesawAngle = (seeSawMotor.getCurrentPosition() * SEESAW_OVERALL_RATIO); // Assuming starting angle is 0
     }
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/DoubleReverse4Bar.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.manipulator;\n\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\n\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\n\npublic class DoubleReverse4Bar {\n    private DcMotorEx liftMotor;\n    private int motorStartPosition;\n\n    public DoubleReverse4Bar(HardwareMap hardwareMap) {\n        liftMotor = hardwareMap.get(DcMotorEx.class, \"lift_motor\"); // connect motor\n        motorStartPosition = liftMotor.getCurrentPosition();\n\n        liftMotor.setDirection(DcMotor.Direction.FORWARD); // set direction\n//        linearMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); // set motor mode\n//        linearMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        liftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE); // set zero power behavior\n\n        liftMotor.setPower(0);\n    }\n\n    public void raise() {\n        liftMotor.setTargetPosition(1000 + motorStartPosition);\n        liftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        liftMotor.setPower(1.0);\n    }\n\n    public void lower() {\n        liftMotor.setTargetPosition(motorStartPosition);\n        liftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        liftMotor.setPower(1.0);\n    }\n\n    public void telemetry(Telemetry telemetry) {\n        telemetry.addData(\"Lift Motor Current\", liftMotor.getCurrentPosition());\n        telemetry.addData(\"Lift Motor Target\", liftMotor.getTargetPosition());\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/DoubleReverse4Bar.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/DoubleReverse4Bar.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/DoubleReverse4Bar.java	(revision 2be55ab5b12b22c403d0b64863796427ca84192b)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/manipulator/DoubleReverse4Bar.java	(date 1666828822172)
@@ -9,29 +9,36 @@
 public class DoubleReverse4Bar {
     private DcMotorEx liftMotor;
     private int motorStartPosition;
+    private static final double OVERALL_RATIO = 1.0; // ticks to inches raised, not negative
+    private static final double STARTING_HEIGHT = 8.0; // inches, should be default
+    public static double manipulatorHeight = STARTING_HEIGHT;
 
     public DoubleReverse4Bar(HardwareMap hardwareMap) {
         liftMotor = hardwareMap.get(DcMotorEx.class, "lift_motor"); // connect motor
         motorStartPosition = liftMotor.getCurrentPosition();
 
         liftMotor.setDirection(DcMotor.Direction.FORWARD); // set direction
-//        linearMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); // set motor mode
-//        linearMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
+        //linearMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); // set motor mode
+        //linearMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
         liftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE); // set zero power behavior
-
-        liftMotor.setPower(0);
-    }
-
-    public void raise() {
-        liftMotor.setTargetPosition(1000 + motorStartPosition);
-        liftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
-        liftMotor.setPower(1.0);
-    }
-
-    public void lower() {
-        liftMotor.setTargetPosition(motorStartPosition);
         liftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        liftMotor.setPower(0);
+    }
+
+    public void raiseTo(double height) { // Does conversion to ticks in the method
+        liftMotor.setTargetPosition((int) ((height - STARTING_HEIGHT) / OVERALL_RATIO)); // Assuming that starting ticks is 0
+        if(liftMotor.getTargetPosition() > liftMotor.getCurrentPosition()){
+            liftMotor.setPower(1.0); // Assuming 1 gearing, pulling the thign down
+        }else{
+            liftMotor.setPower(-1.0);
+        }
         liftMotor.setPower(1.0);
+        // Needs to use turntable method to achieve correct angle, robot needs to drive to correct radius from junction
+    }
+
+    public void update(){ // Run this if other methods are dependant on the data here
+        manipulatorHeight = STARTING_HEIGHT + (liftMotor.getCurrentPosition() * OVERALL_RATIO);
     }
 
     public void telemetry(Telemetry telemetry) {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/Vector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drivetrain;\n\npublic class Vector {\n    private double [] vector;\n\n    public Vector(double [] vector){\n        this.vector = vector;\n    }\n\n    public Vector(double x, double y) {this.vector = new double[] {x, y}; }\n    public Vector() {this.vector = new double[] {0, 0}; }\n\n    public Vector(Vector vector){\n        this.set(0, vector.get()[0]);\n        this.set(1, vector.get()[1]);\n    }\n\n    public double [] get(){\n        return this.vector;\n    }\n\n    public void set(int i, double num){\n        this.vector[i] = num;\n    }\n\n    public void set(Vector vector){\n        for(int i = 0; i < vector.get().length; i++){\n            this.set(i, vector.get()[i]);\n        }\n    }\n\n    public Vector neg(Vector vector){\n        for(double thisNum : vector.get()){\n            thisNum = -thisNum;\n        }\n\n        return this;\n    }\n\n    public Vector add(Vector vector){\n        if(vector.get().length == this.get().length){\n            for(int i = 0; i < vector.get().length; i++) {\n                this.set(i, this.get()[i] + vector.get()[i]);\n            }\n        }\n\n        return this;\n    }\n\n    public double dot(Vector vector){\n        int total = 0;\n\n        if(vector.get().length == this.get().length){\n            for(int i = 0; i < vector.get().length; i++){\n                total += this.get()[i] * vector.get()[i];\n            }\n        }\n\n        return total;\n    }\n\n    public Vector multiply(double coeff){\n        for(int i = 0; i < this.vector.length; i++){\n            this.set(i, this.vector[i] * coeff);\n        }\n\n        return this;\n    }\n\n    public double length(){\n        double length = 0.0;\n\n        for(double thisNum : this.get()){\n            length += thisNum * thisNum;\n        }\n\n        return (Math.sqrt(length));\n    }\n\n    public Vector normalize(){\n        double length = this.length();\n\n        for(int i = 0; i < this.get().length; i++){\n            this.set(i, this.get()[i] / length);\n        }\n\n        return this;\n    }\n\n    public void rotate(double angleChange){ // Radians\n        this.set(0, Math.cos(angleChange) * this.get()[0] - Math.sin(angleChange) * this.get()[1]);\n        this.set(1, Math.sin(angleChange) * this.get()[0] + Math.cos(angleChange) * this.get()[1]);\n    }\n\n    /*public Vector multiply(Matrix matrix){\n        double [] newVector = new double [this.get().length];\n\n        for(int i = 0; i < newVector.length; i++){\n            this.set(i, matrix.row(i).dot(this));\n        }\n\n        return this;\n    }*/\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/Vector.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/Vector.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/Vector.java	(revision 2be55ab5b12b22c403d0b64863796427ca84192b)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/Vector.java	(date 1666828442897)
@@ -87,9 +87,11 @@
         return this;
     }
 
-    public void rotate(double angleChange){ // Radians
+    public Vector rotate(double angleChange){ // Radians
         this.set(0, Math.cos(angleChange) * this.get()[0] - Math.sin(angleChange) * this.get()[1]);
         this.set(1, Math.sin(angleChange) * this.get()[0] + Math.cos(angleChange) * this.get()[1]);
+
+        return this;
     }
 
     /*public Vector multiply(Matrix matrix){
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drivetrain;\n\nimport com.qualcomm.hardware.bosch.BNO055IMU;\nimport com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\n\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\nimport org.firstinspires.ftc.teamcode.odometry.Odometry;\n\npublic class MecanumDrive {\n    public DcMotorEx FRMotor;\n    public DcMotorEx FLMotor;\n    public DcMotorEx BRMotor;\n    public DcMotorEx BLMotor;\n\n    Odometry odometry;\n\n    // Order for power values: FL, FR, RL, RR\n    // Make sure to normalize power values 0 to 1\n    public static final double [] NULL = {0.0, 0.0, 0.0, 0.0};\n\n    public static final double [] backwards = {-1.0, 1,0, -1.0, 1.0};\n    public Vector BACKWARDS = new Vector(backwards);\n//    public Vector BACKWARDS = new Vector(new double[]{-1.0, 1,0, -1.0, 1.0});\n\n    public static final double [] rightVector = {1.0, 1.0, -1.0, -1.0};\n    public Vector RIGHT = new Vector(new double[]{1.0, 1.0, -1.0, -1.0});\n\n    public static final double [] turnRight = {-1.0, -1.0, -1.0, -1.0};\n    public Vector TURN_RIGHT = new Vector(new double[]{-1.0, -1.0, -1.0, -1.0});\n\n    public DcMotorEx [] MOTORS;\n\n\n    // Navigation\n    public static final double [] NULL_POSITION = {0.0, 0.0};\n    public static final double [] DEFAULT_DIRECTION = {1.0, 0.0}; //Unit direction vector\n\n    public static final double MAX = 3.1416; //Max speed\n\n    Vector position;\n    Vector velocity;\n    Vector drive;\n    Vector displacement;\n\n    Vector translation;\n    Vector rotation;\n\n    int time;\n    double maxValue;\n\n    private BNO055IMU imu;\n\n    public MecanumDrive(HardwareMap hardwareMap, Telemetry telemetry) {\n        // Connect Motors\n        FRMotor = hardwareMap.get(DcMotorEx.class, \"FR\");\n        FLMotor = hardwareMap.get(DcMotorEx.class, \"FL\");\n        BRMotor = hardwareMap.get(DcMotorEx.class, \"BR\");\n        BLMotor = hardwareMap.get(DcMotorEx.class, \"BL\");\n\n        // Set Directions\n        FRMotor.setDirection(DcMotor.Direction.FORWARD);\n        FLMotor.setDirection(DcMotor.Direction.REVERSE);\n        BRMotor.setDirection(DcMotor.Direction.FORWARD);\n        BLMotor.setDirection(DcMotor.Direction.REVERSE);\n\n        // Set Motor Mode\n        FRMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        FLMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        BRMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        BLMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        FRMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        FLMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        BRMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        BLMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n        // Set Zero Power Behavior\n        FRMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        FLMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        BRMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        BLMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        // Stops Motors on INIT\n        FRMotor.setPower(0);\n        FLMotor.setPower(0);\n        BRMotor.setPower(0);\n        BLMotor.setPower(0);\n\n        //\n//        FRMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));\n//        FLMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));\n//        BRMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));\n//        BLMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));\n\n        MOTORS = new DcMotorEx[]{FLMotor, FRMotor, BLMotor, BRMotor};\n\n        velocity = new Vector(NULL_POSITION);\n        drive = new Vector(NULL);\n        displacement = new Vector(DEFAULT_DIRECTION);\n        translation = new Vector(NULL_POSITION);\n        rotation = new Vector(NULL_POSITION);\n\n        time = 0;\n\n//        drive.set(new Vector(new double[]{1, 1, 1, 1}));\n\n\n        //IMU\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n        parameters.angleUnit           = BNO055IMU.AngleUnit.DEGREES;\n        parameters.accelUnit           = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n        parameters.calibrationDataFile = \"BNO055IMUCalibration.json\";\n        parameters.loggingEnabled      = true;\n        parameters.loggingTag          = \"IMU\";\n        parameters.accelerationIntegrationAlgorithm = new JustLoggingAccelerationIntegrator();\n\n        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n        imu.initialize(parameters);\n    }\n\n    public void drive(double x, double y, double rotate) {\n        FRMotor.setPower(-x - y - rotate);\n        FLMotor.setPower(-x + y - rotate);\n        BRMotor.setPower(-x + y + rotate);\n        BLMotor.setPower(-x - y + rotate);\n    }\n\n    public void vectorDrive(double x, double y, double rotate, Telemetry telemetry) {\n        telemetry.addData(\"backwards[0]\", backwards[0]);\n        telemetry.addData(\"BACKWARDS.get()[0]\", BACKWARDS.get()[0]);\n//        telemetry.addData(\"rightVector[0]\", rightVector[0]);\n        telemetry.addData(\"RIGHT.get()[0\", RIGHT.get()[0]);\n        translation = BACKWARDS.multiply(y).add(RIGHT.multiply(x));\n        rotation = TURN_RIGHT.multiply(rotate);\n        drive = translation.add(rotation);\n\n        double maxValue = 0.0;\n        for(double thisNum : drive.get()){\n            if(Math.abs(thisNum) > maxValue){\n                maxValue = thisNum;\n            }\n        }\n\n        setPowers(drive.multiply(1.0 / maxValue), telemetry);\n\n        telemetry.addLine(\"Right: \" + (MAX * x));\n        telemetry.addLine(\"Forwards: \" + (MAX * -1 * -y));\n//        telemetry.addLine(position.get()[0] + \", \" + position.get()[1]);\n    }\n\n    public void goToPosition(double targetXPosition, double targetYPosition, double power, double targetOrientation) {\n        double distanceToXTarget = targetXPosition - odometry.getXCoordinate();\n        double distanceToYTarget = targetYPosition - odometry.getYCoordinate();\n\n        double distance = Math.hypot(distanceToXTarget, distanceToYTarget);\n\n        while(FRMotor.isBusy() && FLMotor.isBusy() && BRMotor.isBusy() && BLMotor.isBusy()) {\n            distanceToXTarget = targetXPosition - odometry.getXCoordinate();\n            distanceToYTarget = targetYPosition - odometry.getYCoordinate();\n\n            double robotAngle = Math.toDegrees(Math.atan2(distanceToXTarget, distanceToYTarget));\n\n\n        }\n    }\n\n    public void fieldOrientatedDrive(double x, double y, double rotate) {\n\n        Orientation angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n\n        float pi = 3.1415926f;\n\n        float gyro_degrees = angles.firstAngle;\n        float gyro_radians = gyro_degrees * pi / 180;\n\n        x = x * Math.cos(gyro_radians) - y * Math.sin(gyro_radians);\n        y = x * Math.sin(gyro_radians) + y * Math.cos(gyro_radians);\n\n        double[] speeds = {\n                (x + y + rotate),\n                (x - y - rotate),\n                (x - y + rotate),\n                (x + y - rotate)\n        };\n\n        double max = Math.abs(speeds[0]);\n        for (int i = 0; i < speeds.length; i++) {\n            if (max < Math.abs(speeds[i])) {\n                max = Math.abs(speeds[i]);\n            }\n        }\n\n        FLMotor.setPower(speeds[0]);\n        FRMotor.setPower(speeds[1]);\n        BLMotor.setPower(speeds[2]);\n        BRMotor.setPower(speeds[3]);\n    }\n\n//    public void driveTo(Vector target, Vector currentPosition){ // Probably run this every few ticks\n//        displacement = target.add(currentPosition.multiply(-1)); // Normalize this when inputting for ratios\n//\n//        drive = RIGHT.multiply(displacement.normalize().get()[0])\n//                .add(BACKWARDS.multiply(displacement.normalize().get()[1]));\n//\n//        setPowers(MOTORS, drive);\n//    }\n\n    @Deprecated\n    public static void setVelocities(DcMotorEx [] motors, Vector vector){\n        for(int i = 0; i < vector.get().length; i++){\n            motors[i].setVelocity(vector.get()[i] * MAX);\n        }\n    }\n\n    public void setPowers(Vector vector, Telemetry telemetry){\n//        for(int i = 0; i < motors.length; i++){\n//            motors[i].setPower(vector.get()[i]);\n//            telemetry.addData(\"powa\", vector.get()[i]);\n//        }\n\n        FLMotor.setPower(vector.get()[0]);\n        FRMotor.setPower(vector.get()[1]);\n        BLMotor.setPower(vector.get()[2]);\n        BRMotor.setPower(vector.get()[3]);\n        telemetry.addData(\"powa\", vector.get()[0]);\n    }\n\n    public void telemetry(Telemetry telemetry) {\n        telemetry.addData(\"FR Motor Position\", FRMotor.getCurrentPosition());\n        telemetry.addData(\"FL Motor Position\", FLMotor.getCurrentPosition());\n        telemetry.addData(\"BR Motor Position\", BRMotor.getCurrentPosition());\n        telemetry.addData(\"BL Motor Position\", BLMotor.getCurrentPosition());\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java	(revision 2be55ab5b12b22c403d0b64863796427ca84192b)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java	(date 1666828535497)
@@ -1,5 +1,8 @@
 package org.firstinspires.ftc.teamcode.drivetrain;
 
+import static org.firstinspires.ftc.teamcode.highlevel.Master.currentPosition;
+import static org.firstinspires.ftc.teamcode.highlevel.Master.odometryAlg;
+
 import com.qualcomm.hardware.bosch.BNO055IMU;
 import com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;
 import com.qualcomm.robotcore.hardware.DcMotor;
@@ -11,7 +14,9 @@
 import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
 import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
 import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
+import org.firstinspires.ftc.teamcode.highlevel.Master.*;
 import org.firstinspires.ftc.teamcode.odometry.Odometry;
+//import org.firstinspires.ftc.teamcode.odometry.Odometry;
 
 public class MecanumDrive {
     public DcMotorEx FRMotor;
@@ -27,16 +32,14 @@
 
     public static final double [] backwards = {-1.0, 1,0, -1.0, 1.0};
     public Vector BACKWARDS = new Vector(backwards);
-//    public Vector BACKWARDS = new Vector(new double[]{-1.0, 1,0, -1.0, 1.0});
 
     public static final double [] rightVector = {1.0, 1.0, -1.0, -1.0};
-    public Vector RIGHT = new Vector(new double[]{1.0, 1.0, -1.0, -1.0});
+    public Vector RIGHT = new Vector(rightVector);
 
     public static final double [] turnRight = {-1.0, -1.0, -1.0, -1.0};
-    public Vector TURN_RIGHT = new Vector(new double[]{-1.0, -1.0, -1.0, -1.0});
+    public Vector TURN_RIGHT = new Vector(turnRight);
 
-    public DcMotorEx [] MOTORS;
-
+    public DcMotorEx [] MOTORS = {FLMotor, FRMotor, BLMotor, BRMotor};
 
     // Navigation
     public static final double [] NULL_POSITION = {0.0, 0.0};
@@ -44,20 +47,20 @@
 
     public static final double MAX = 3.1416; //Max speed
 
-    Vector position;
-    Vector velocity;
-    Vector drive;
-    Vector displacement;
+    private Vector position;
+    private Vector velocity;
+    private Vector drive;
+    private Vector displacement;
 
-    Vector translation;
-    Vector rotation;
+    private Vector translation;
+    private Vector rotation;
 
     int time;
     double maxValue;
 
     private BNO055IMU imu;
 
-    public MecanumDrive(HardwareMap hardwareMap, Telemetry telemetry) {
+    public MecanumDrive(HardwareMap hardwareMap) {
         // Connect Motors
         FRMotor = hardwareMap.get(DcMotorEx.class, "FR");
         FLMotor = hardwareMap.get(DcMotorEx.class, "FL");
@@ -94,22 +97,20 @@
         BLMotor.setPower(0);
 
         //
-//        FRMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));
-//        FLMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));
-//        BRMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));
-//        BLMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));
+        /*FRMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));
+        FLMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));
+        BRMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));
+        BLMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));*/
 
-        MOTORS = new DcMotorEx[]{FLMotor, FRMotor, BLMotor, BRMotor};
+
 
         velocity = new Vector(NULL_POSITION);
         drive = new Vector(NULL);
-        displacement = new Vector(DEFAULT_DIRECTION);
+        displacement = new Vector(new double [] {0.0, 0.0});
         translation = new Vector(NULL_POSITION);
         rotation = new Vector(NULL_POSITION);
 
-        time = 0;
-
-//        drive.set(new Vector(new double[]{1, 1, 1, 1}));
+        time = 0; // Ticks ig
 
 
         //IMU
@@ -126,18 +127,17 @@
     }
 
     public void drive(double x, double y, double rotate) {
-        FRMotor.setPower(-x - y - rotate);
-        FLMotor.setPower(-x + y - rotate);
-        BRMotor.setPower(-x + y + rotate);
-        BLMotor.setPower(-x - y + rotate);
+        double max = Math.max((-x - y - rotate), Math.max((-x + y + rotate), Math.max((-x + y - rotate), (-x - y + rotate))));
+
+        FRMotor.setPower((-x - y - rotate) / max);
+        FLMotor.setPower((-x + y - rotate) / max);
+        BRMotor.setPower((-x + y + rotate) / max);
+        BLMotor.setPower((-x - y + rotate) /  max);
     }
 
     public void vectorDrive(double x, double y, double rotate, Telemetry telemetry) {
-        telemetry.addData("backwards[0]", backwards[0]);
-        telemetry.addData("BACKWARDS.get()[0]", BACKWARDS.get()[0]);
-//        telemetry.addData("rightVector[0]", rightVector[0]);
-        telemetry.addData("RIGHT.get()[0", RIGHT.get()[0]);
-        translation = BACKWARDS.multiply(y).add(RIGHT.multiply(x));
+//        odometryAlg.updateOrientationAndLocation();
+        translation = BACKWARDS.multiply(-y).add(RIGHT.multiply(x)).rotate(0.0); // -orientationAngle for rotation
         rotation = TURN_RIGHT.multiply(rotate);
         drive = translation.add(rotation);
 
@@ -148,28 +148,28 @@
             }
         }
 
-        setPowers(drive.multiply(1.0 / maxValue), telemetry);
+        setPowers(MOTORS, drive.multiply(1.0 / maxValue));
 
-        telemetry.addLine("Right: " + (MAX * x));
-        telemetry.addLine("Forwards: " + (MAX * -1 * -y));
-//        telemetry.addLine(position.get()[0] + ", " + position.get()[1]);
+        telemetry.addLine("Right: " + (MAX * x) +  "Forwards: " + (MAX * -1 * -y));
+        //telemetry.addLine(position.get()[0] + ", " + position.get()[1]);
+        telemetry.update();
     }
 
-    public void goToPosition(double targetXPosition, double targetYPosition, double power, double targetOrientation) {
-        double distanceToXTarget = targetXPosition - odometry.getXCoordinate();
-        double distanceToYTarget = targetYPosition - odometry.getYCoordinate();
-
-        double distance = Math.hypot(distanceToXTarget, distanceToYTarget);
-
-        while(FRMotor.isBusy() && FLMotor.isBusy() && BRMotor.isBusy() && BLMotor.isBusy()) {
-            distanceToXTarget = targetXPosition - odometry.getXCoordinate();
-            distanceToYTarget = targetYPosition - odometry.getYCoordinate();
-
-            double robotAngle = Math.toDegrees(Math.atan2(distanceToXTarget, distanceToYTarget));
-
-
-        }
-    }
+//    public void goToPosition(double targetXPosition, double targetYPosition, double power, double targetOrientation) {
+//        double distanceToXTarget = targetXPosition - odometry.getXCoordinate();
+//        double distanceToYTarget = targetYPosition - odometry.getYCoordinate();
+//
+//        double distance = Math.hypot(distanceToXTarget, distanceToYTarget);
+//
+//        while(FRMotor.isBusy() && FLMotor.isBusy() && BRMotor.isBusy() && BLMotor.isBusy()) {
+//            distanceToXTarget = targetXPosition - odometry.getXCoordinate();
+//            distanceToYTarget = targetYPosition - odometry.getYCoordinate();
+//
+//            double robotAngle = Math.toDegrees(Math.atan2(distanceToXTarget, distanceToYTarget));
+//
+//
+//        }
+//    }
 
     public void fieldOrientatedDrive(double x, double y, double rotate) {
 
@@ -203,14 +203,24 @@
         BRMotor.setPower(speeds[3]);
     }
 
-//    public void driveTo(Vector target, Vector currentPosition){ // Probably run this every few ticks
-//        displacement = target.add(currentPosition.multiply(-1)); // Normalize this when inputting for ratios
-//
-//        drive = RIGHT.multiply(displacement.normalize().get()[0])
-//                .add(BACKWARDS.multiply(displacement.normalize().get()[1]));
-//
-//        setPowers(MOTORS, drive);
-//    }
+    public static double sensitivity = 5.0; // "Steepness" of gradient vectors
+    public Vector correct(){
+        odometryAlg.updateOrientationAndLocation();
+        displacement.set(0, -sensitivity * ((currentPosition.get()[0] % 22.75) - 11.375));
+        displacement.set(1, -sensitivity * ((currentPosition.get()[1] % 22.75) - 11.375));
+
+        return translation.add(displacement);
+    }
+
+    public void driveTo(Vector target, Vector currentPosition){ // Probably run this every few ticks
+        odometryAlg.updateOrientationAndLocation();
+        displacement = target.add(currentPosition.multiply(-1)); // Normalize this when inputting for ratios
+
+        drive = RIGHT.multiply(displacement.normalize().get()[0])
+                .add(BACKWARDS.multiply(displacement.normalize().get()[1]));
+
+        setPowers(MOTORS, drive);
+    }
 
     @Deprecated
     public static void setVelocities(DcMotorEx [] motors, Vector vector){
@@ -219,17 +229,10 @@
         }
     }
 
-    public void setPowers(Vector vector, Telemetry telemetry){
-//        for(int i = 0; i < motors.length; i++){
-//            motors[i].setPower(vector.get()[i]);
-//            telemetry.addData("powa", vector.get()[i]);
-//        }
-
-        FLMotor.setPower(vector.get()[0]);
-        FRMotor.setPower(vector.get()[1]);
-        BLMotor.setPower(vector.get()[2]);
-        BRMotor.setPower(vector.get()[3]);
-        telemetry.addData("powa", vector.get()[0]);
+    public static void setPowers(DcMotorEx [] motors, Vector vector){
+        for(int i = 0; i < vector.get().length; i++){
+            motors[i].setPower(vector.get()[i]);
+        }
     }
 
     public void telemetry(Telemetry telemetry) {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/Master.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Add import statements as more data is added\n// Auxillary (driver hub, control hub, OD, etc...)\npackage org.firstinspires.ftc.teamcode.highlevel;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\nimport org.firstinspires.ftc.teamcode.drivetrain.*;\n\n// Encoders, Motors\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\n\n// Servos\n\n\n\n\n// Everything public except for in-class default values!!!!!!!!!\npublic class Master {\n    public static HardwareMap hardwaremap;\n\n    // Controller\n\n    // Driver hub and Vuforia\n    public Telemetry telemetry;\n\n    // Odometry                             ________\n    public static DcMotorEx encoder1; //   |   ==   |\n    public static DcMotorEx encoder2; //   ||       |\n    public static DcMotorEx encoder3; //   |   ==   | encoder 1 on top, encoder 2 on bottom, encoder3 on left\n    //                                      ˜˜˜˜˜˜˜˜\n    public static Vector currentPosition;\n    public static Vector travel;\n    public static Vector orientation;\n    public static Vector normalOrientation;\n\n    // Used to update encoder deltas\n    public static double encoder1Reading;\n    public static double encoder2Reading;\n    public static double encoder3Reading;\n\n    private static final double [] DEFAULT_POSITION = {0, 0}; // Get actual robot starting coordinates in inches on Friday, bottom left relative to our starting side is origin\n    // Probably write calibration method w/ tape and obj recognition\n    public static final Vector STARTING_POSITION = new Vector(DEFAULT_POSITION);\n\n\n    // Drive motors\n\n    // Manipulator\n\n\n\n\n\n    // Constructor to fully instantiate robot\n    public void initEverything(){\n\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/Master.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/Master.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/Master.java	(revision 2be55ab5b12b22c403d0b64863796427ca84192b)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/Master.java	(date 1666828171797)
@@ -1,8 +1,13 @@
 // Add import statements as more data is added
 // Auxillary (driver hub, control hub, OD, etc...)
 package org.firstinspires.ftc.teamcode.highlevel;
+import com.qualcomm.robotcore.hardware.Gamepad;
 import com.qualcomm.robotcore.hardware.HardwareMap;
 import org.firstinspires.ftc.robotcore.external.Telemetry;
+import org.firstinspires.ftc.teamcode.manipulator.DoubleReverse4Bar;
+import org.firstinspires.ftc.teamcode.manipulator.LinearSlides;
+import org.firstinspires.ftc.teamcode.manipulator.Turntable;
+import org.firstinspires.ftc.teamcode.odometry.TestingOdometryAlgorithm;
 import org.firstinspires.ftc.teamcode.drivetrain.*;
 
 // Encoders, Motors
@@ -18,9 +23,11 @@
     public static HardwareMap hardwaremap;
 
     // Controller
+    public static Gamepad gamepad1;
+    public static Gamepad gamepad2;
 
     // Driver hub and Vuforia
-    public Telemetry telemetry;
+    public static Telemetry telemetry;
 
     // Odometry                             ________
     public static DcMotorEx encoder1; //   |   ==   |
@@ -39,19 +46,38 @@
 
     private static final double [] DEFAULT_POSITION = {0, 0}; // Get actual robot starting coordinates in inches on Friday, bottom left relative to our starting side is origin
     // Probably write calibration method w/ tape and obj recognition
-    public static final Vector STARTING_POSITION = new Vector(DEFAULT_POSITION);
-
+    public static Vector STARTING_POSITION;
+    public static MecanumDrive drive;
 
     // Drive motors
 
     // Manipulator
-
-
-
-
-
+    GridSystem grid;
+    public static Turntable turntable;
+    public static LinearSlides manipulator1;
+    public static DoubleReverse4Bar manipulator2;
+    public static double turntableAngle; // Radians, as always
+    public static TestingOdometryAlgorithm odometryAlg; // Add this
     // Constructor to fully instantiate robot
-    public void initEverything(){
+    public static void initEverything(){ // Lets finish this sometime lol
+        STARTING_POSITION = new Vector(DEFAULT_POSITION);
+        gamepad1 = hardwaremap.get(Gamepad.class, "Gamepad 1");
+        gamepad2 = hardwaremap.get(Gamepad.class, "Gamepad 2");
+
+        drive = new MecanumDrive(hardwaremap, telemetry);
+        odometryAlg = new TestingOdometryAlgorithm(STARTING_POSITION);
+
+        manipulator1 = new LinearSlides();
+        manipulator2 = new DoubleReverse4Bar(hardwaremap);
+    }
 
+    public static double invSqrt(double x) { // Use this for inverse square root ig, gotta tell judges we used some innovative bit shift algorithm originally in C++ or smth
+        double xhalf = 0.5d * x;
+        long i = Double.doubleToLongBits(x);
+        i = 0x5fe6ec85e7de30daL - (i >> 1);
+        x = Double.longBitsToDouble(i);
+        x *= (1.5d - xhalf * x * x);
+        return x;
     }
+
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/TeleOp1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/TeleOp1.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/TeleOp1.java
new file mode 100644
--- /dev/null	(date 1666828776729)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/TeleOp1.java	(date 1666828776729)
@@ -0,0 +1,30 @@
+package org.firstinspires.ftc.teamcode.highlevel;
+
+import static org.firstinspires.ftc.teamcode.highlevel.Master.drive;
+import static org.firstinspires.ftc.teamcode.highlevel.Master.initEverything;
+
+import com.qualcomm.robotcore.eventloop.opmode.OpMode;
+import com.qualcomm.robotcore.hardware.Gamepad;
+import com.qualcomm.robotcore.hardware.HardwareMap;
+import org.firstinspires.ftc.robotcore.external.Telemetry;
+import org.firstinspires.ftc.teamcode.manipulator.LinearSlides;
+import org.firstinspires.ftc.teamcode.manipulator.Turntable;
+import org.firstinspires.ftc.teamcode.drivetrain.*;
+
+// Encoders, Motors
+import com.qualcomm.robotcore.hardware.DcMotorEx;
+
+public class TeleOp1 extends OpMode {
+
+    @Override
+    public void init() {
+        initEverything();
+    }
+
+    @Override
+    public void loop() {
+
+        drive.vectorDrive(gamepad1.left_stick_x, -gamepad1.left_stick_y, gamepad1.right_stick_x, telemetry);
+
+    }
+}
