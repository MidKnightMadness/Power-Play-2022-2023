Index: FtcRobotController/build/generated/source/buildConfig/debug/com/qualcomm/ftcrobotcontroller/BuildConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\n * Automatically generated file. DO NOT MODIFY\n */\npackage com.qualcomm.ftcrobotcontroller;\n\npublic final class BuildConfig {\n  public static final boolean DEBUG = Boolean.parseBoolean(\"true\");\n  public static final String LIBRARY_PACKAGE_NAME = \"com.qualcomm.ftcrobotcontroller\";\n  public static final String BUILD_TYPE = \"debug\";\n  // Field from default config.\n  public static final String APP_BUILD_TIME = \"2022-10-28T16:02:23.421-0700\";\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FtcRobotController/build/generated/source/buildConfig/debug/com/qualcomm/ftcrobotcontroller/BuildConfig.java b/FtcRobotController/build/generated/source/buildConfig/debug/com/qualcomm/ftcrobotcontroller/BuildConfig.java
--- a/FtcRobotController/build/generated/source/buildConfig/debug/com/qualcomm/ftcrobotcontroller/BuildConfig.java	(revision 63c7ed779f50fdc57ce89c510026183939f8d54d)
+++ b/FtcRobotController/build/generated/source/buildConfig/debug/com/qualcomm/ftcrobotcontroller/BuildConfig.java	(date 1667000301580)
@@ -8,5 +8,5 @@
   public static final String LIBRARY_PACKAGE_NAME = "com.qualcomm.ftcrobotcontroller";
   public static final String BUILD_TYPE = "debug";
   // Field from default config.
-  public static final String APP_BUILD_TIME = "2022-10-28T16:02:23.421-0700";
+  public static final String APP_BUILD_TIME = "2022-10-28T16:38:21.190-0700";
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MainTeleOp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\n\nimport static org.firstinspires.ftc.teamcode.highlevel.Master.drive;\n\n\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n\nimport org.firstinspires.ftc.teamcode.drivetrain.MecanumDrive;\nimport org.firstinspires.ftc.teamcode.manipulator.LinearSlides;\nimport org.firstinspires.ftc.teamcode.manipulator.Turntable;\nimport org.firstinspires.ftc.teamcode.odometry.*;\nimport org.firstinspires.ftc.teamcode.odometry.TestingOdometryAlgorithm;\nimport org.firstinspires.ftc.teamcode.highlevel.Master;\n\n@TeleOp(name=\"Main\")\npublic class MainTeleOp extends OpMode {\n\n    @Override\n    public void init() {\n\n    }\n\n    @Override\n    public void loop() {\n        // DRIVER ASSIST\n        //mecanum.drive(gamepad1.left_stick_x, gamepad1.left_stick_y, gamepad1.right_stick_y); // normal drive\n        //mecanum.vectorDrive(gamepad1.left_stick_x, gamepad1.left_stick_y, gamepad1.right_stick_y, telemetry);\n//        drive.fieldOrientatedDrive(gamepad1.left_stick_x, gamepad1.left_stick_y, gamepad1.right_stick_y, telemetry);\n\n        // LIFT (LINEAR SLIDES)\n        /*if (gamepad2.dpad_up && !lastPressedLiftMotor) {\n            liftMotorToggle = !liftMotorToggle;\n        }\n        if (liftMotorToggle) {\n            lift.raise(1000);\n        } else {\n            lift.lower();\n        }\n        lastPressedLiftMotor = gamepad2.dpad_up;*/\n\n        // LIFT (DOUBLE REVERSE 4 BAR)\n        /*if (gamepad2.dpad_up && !lastPressedLiftMotor) {\n            liftMotorToggle = !liftMotorToggle;\n        }\n        if (liftMotorToggle) {\n            lift.raise();\n        } else {\n            lift.lower();\n        }\n        lastPressedLiftMotor = gamepad2.dpad_up;*/\n\n        // TURNTABLE\n        /*if (gamepad2.right_stick_x != 0) {\n            turntable.turn(gamepad2.right_stick_x);\n        }*/\n\n\n//        odometry.updateTime();\n//        odometry.updatePosition();\n//\n//        // TELEMETRY\n//        odometry.telemetry(telemetry);\n//        mecanum.telemetry(telemetry);\n        telemetry.update();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MainTeleOp.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MainTeleOp.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MainTeleOp.java	(revision 63c7ed779f50fdc57ce89c510026183939f8d54d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MainTeleOp.java	(date 1666998915277)
@@ -1,6 +1,6 @@
 package org.firstinspires.ftc.teamcode;
 
-import static org.firstinspires.ftc.teamcode.highlevel.Master.drive;
+
 
 
 import com.qualcomm.robotcore.eventloop.opmode.OpMode;
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/TeleOp1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.highlevel;\n\nimport static org.firstinspires.ftc.teamcode.highlevel.Master.drive;\nimport static org.firstinspires.ftc.teamcode.highlevel.Master.hardwaremap;\n\n\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.Gamepad;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\nimport org.firstinspires.ftc.teamcode.manipulator.LinearSlides;\nimport org.firstinspires.ftc.teamcode.manipulator.Turntable;\nimport org.firstinspires.ftc.teamcode.drivetrain.*;\n\n// Encoders, Motors\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\n\n@TeleOp\npublic class TeleOp1 extends OpMode {\n    public static Gamepad gamepad1;\n\n    Master master;\n    @Override\n    public void init() {\n        master = new Master();\n    }\n\n    @Override\n    public void loop() {\n        gamepad1 = hardwaremap.get(Gamepad.class, \"Gamepad 1\");\n\n        drive.vectorDrive(gamepad1.left_stick_x, -gamepad1.left_stick_y, gamepad1.right_stick_x, telemetry);\n\n        telemetry.addLine(String.format(\"∆x: [%3.1f%, %3.1f\\nrotation: %3.1f\", gamepad1.left_stick_x, -gamepad1.left_stick_y, gamepad1.right_stick_x));\n        telemetry.update();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/TeleOp1.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/TeleOp1.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/TeleOp1.java	(revision 63c7ed779f50fdc57ce89c510026183939f8d54d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/TeleOp1.java	(date 1667000300319)
@@ -1,13 +1,10 @@
 package org.firstinspires.ftc.teamcode.highlevel;
 
-import static org.firstinspires.ftc.teamcode.highlevel.Master.drive;
 import static org.firstinspires.ftc.teamcode.highlevel.Master.hardwaremap;
 
 
 import com.qualcomm.robotcore.eventloop.opmode.OpMode;
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
-import com.qualcomm.robotcore.hardware.Gamepad;
-import com.qualcomm.robotcore.hardware.HardwareMap;
 import org.firstinspires.ftc.robotcore.external.Telemetry;
 import org.firstinspires.ftc.teamcode.manipulator.LinearSlides;
 import org.firstinspires.ftc.teamcode.manipulator.Turntable;
@@ -18,21 +15,22 @@
 
 @TeleOp
 public class TeleOp1 extends OpMode {
-    public static Gamepad gamepad1;
+
 
     Master master;
+    MecanumDrive drive;
+
     @Override
     public void init() {
-        master = new Master();
+        drive = new MecanumDrive(hardwareMap);
+
     }
 
     @Override
     public void loop() {
-        gamepad1 = hardwaremap.get(Gamepad.class, "Gamepad 1");
-
         drive.vectorDrive(gamepad1.left_stick_x, -gamepad1.left_stick_y, gamepad1.right_stick_x, telemetry);
 
-        telemetry.addLine(String.format("∆x: [%3.1f%, %3.1f\nrotation: %3.1f", gamepad1.left_stick_x, -gamepad1.left_stick_y, gamepad1.right_stick_x));
+        telemetry.addLine(String.format("deltaX: [%3.1f%, %3.1f%nrotation: %3.1f", gamepad1.left_stick_x, -gamepad1.left_stick_y, gamepad1.right_stick_x));
         telemetry.update();
     }
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drivetrain;\n\nimport static org.firstinspires.ftc.teamcode.highlevel.Master.currentPosition;\nimport static org.firstinspires.ftc.teamcode.highlevel.Master.odometryAlg;\n\nimport com.qualcomm.hardware.bosch.BNO055IMU;\nimport com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\n\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\nimport org.firstinspires.ftc.teamcode.highlevel.Master.*;\nimport org.firstinspires.ftc.teamcode.Odometry.Odometry;\n//import org.firstinspires.ftc.teamcode.odometry.Odometry;\n\npublic class MecanumDrive {\n    public DcMotorEx FRMotor;\n    public DcMotorEx FLMotor;\n    public DcMotorEx BRMotor;\n    public DcMotorEx BLMotor;\n\n    Odometry odometry;\n\n    // Order for power values: FL, FR, RL, RR\n    // Make sure to normalize power values 0 to 1\n    public static final double [] NULL = {0.0, 0.0, 0.0, 0.0};\n\n    public static final double [] backwards = {-1.0, 1,0, -1.0, 1.0};\n    public Vector BACKWARDS = new Vector(backwards);\n\n    public static final double [] rightVector = {1.0, 1.0, -1.0, -1.0};\n    public Vector RIGHT = new Vector(rightVector);\n\n    public static final double [] turnRight = {-1.0, -1.0, -1.0, -1.0};\n    public Vector TURN_RIGHT = new Vector(turnRight);\n\n    public DcMotorEx [] MOTORS = {FLMotor, FRMotor, BLMotor, BRMotor};\n\n    // Navigation\n    public static final double [] NULL_POSITION = {0.0, 0.0};\n    public static final double [] DEFAULT_DIRECTION = {1.0, 0.0}; //Unit direction vector\n\n    public static final double MAX = 3.1416; //Max speed\n\n    private Vector position;\n    private Vector velocity;\n    private Vector drive;\n    private Vector displacement;\n\n    private Vector translation;\n    private Vector rotation;\n\n    int time;\n    double maxValue;\n\n    private BNO055IMU imu;\n\n    public MecanumDrive(HardwareMap hardwareMap) {\n        // Connect Motors\n        FRMotor = hardwareMap.get(DcMotorEx.class, \"FR\");\n        FLMotor = hardwareMap.get(DcMotorEx.class, \"FL\");\n        BRMotor = hardwareMap.get(DcMotorEx.class, \"BR\");\n        BLMotor = hardwareMap.get(DcMotorEx.class, \"BL\");\n\n        // Set Directions\n        FRMotor.setDirection(DcMotor.Direction.FORWARD);\n        FLMotor.setDirection(DcMotor.Direction.REVERSE);\n        BRMotor.setDirection(DcMotor.Direction.FORWARD);\n        BLMotor.setDirection(DcMotor.Direction.REVERSE);\n\n        // Set Motor Mode\n        FRMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        FLMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        BRMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        BLMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n        FRMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        FLMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        BRMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        BLMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n        // Set Zero Power Behavior\n        FRMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        FLMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        BRMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        BLMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\n        // Stops Motors on INIT\n        FRMotor.setPower(0);\n        FLMotor.setPower(0);\n        BRMotor.setPower(0);\n        BLMotor.setPower(0);\n\n        //\n//        FRMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));\n//        FLMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));\n//        BRMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));\n//        BLMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));\n\n\n        MOTORS = new DcMotorEx[]{FLMotor, FRMotor, BLMotor, BRMotor};\n\n        velocity = new Vector(NULL_POSITION);\n        drive = new Vector(NULL);\n        displacement = new Vector(new double [] {0.0, 0.0});\n        translation = new Vector(NULL_POSITION);\n        rotation = new Vector(NULL_POSITION);\n\n        time = 0; // Ticks ig\n\n\n        //IMU\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n        parameters.angleUnit           = BNO055IMU.AngleUnit.DEGREES;\n        parameters.accelUnit           = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n        parameters.calibrationDataFile = \"BNO055IMUCalibration.json\";\n        parameters.loggingEnabled      = true;\n        parameters.loggingTag          = \"IMU\";\n        parameters.accelerationIntegrationAlgorithm = new JustLoggingAccelerationIntegrator();\n\n        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n        imu.initialize(parameters);\n    }\n\n    public void drive(double x, double y, double rotate) {\n        FRMotor.setPower(-x + y - rotate);\n        FLMotor.setPower( x + y + rotate);\n        BRMotor.setPower( x + y - rotate);\n        BLMotor.setPower(-x + y + rotate);\n    }\n\n    public void vectorDrive(double x, double y, double rotate, Telemetry telemetry) {\n        telemetry.addData(\"backwards[0]\", backwards[0]);\n        telemetry.addData(\"BACKWARDS.get()[0]\", BACKWARDS.get()[0]);\n//        telemetry.addData(\"rightVector[0]\", rightVector[0]);\n        telemetry.addData(\"RIGHT.get()[0\", RIGHT.get()[0]);\n        translation = BACKWARDS.multiply(y).add(RIGHT.multiply(x));\n        rotation = TURN_RIGHT.multiply(rotate);\n        drive = translation.add(rotation);\n\n        double maxValue = 0.0;\n        for(double thisNum : drive.get()){\n            if(Math.abs(thisNum) > maxValue){\n                maxValue = thisNum;\n            }\n        }\n\n        setPowers(drive.multiply(1.0 / maxValue), telemetry);\n\n        telemetry.addLine(\"Right: \" + (MAX * x));\n        telemetry.addLine(\"Forwards: \" + (MAX * -1 * -y));\n//        telemetry.addLine(position.get()[0] + \", \" + position.get()[1]);\n    }\n\n//    public void goToPosition(double targetXPosition, double targetYPosition, double power, double targetOrientation) {\n//        double distanceToXTarget = targetXPosition - odometry.getXCoordinate();\n//        double distanceToYTarget = targetYPosition - odometry.getYCoordinate();\n//\n//        double distance = Math.hypot(distanceToXTarget, distanceToYTarget);\n//\n//        while(FRMotor.isBusy() && FLMotor.isBusy() && BRMotor.isBusy() && BLMotor.isBusy()) {\n//            distanceToXTarget = targetXPosition - odometry.getXCoordinate();\n//            distanceToYTarget = targetYPosition - odometry.getYCoordinate();\n//\n//            double robotAngle = Math.toDegrees(Math.atan2(distanceToXTarget, distanceToYTarget));\n//\n//\n//        }\n//    }\n\n    public void fieldOrientatedDrive(double x, double y, double rotate, Telemetry telemetry) {\n        Orientation angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n        float pi = 3.1415926f;\n        float gyro_degrees = angles.firstAngle;\n        float gyro_radians = gyro_degrees * pi / 180;\n\n        y = -y;\n        double offAngle = 0;\n\n        if (x != 0) offAngle = Math.atan(y / x);\n\n        if (x <= 0){ // Getting displacement angle\n            offAngle = Math.PI - offAngle; // Might wanna use taylor series to approximate atan later since calculation times are gonna be annoying\n        }\n        double correctedX = Math.cos(gyro_radians - offAngle);\n        double correctedY = Math.sin(gyro_radians - offAngle);\n\n        correctedX = -correctedX;\n        correctedY = -correctedY;\n\n        FRMotor.setPower(-correctedX + correctedY - rotate);\n        FLMotor.setPower( correctedX + correctedY + rotate);\n        BRMotor.setPower( correctedX + correctedY - rotate);\n        BLMotor.setPower(-correctedX + correctedY + rotate);\n\n        telemetry.addData(\"x2\", correctedX);\n        telemetry.addData(\"y2\", correctedY);\n        telemetry.addData(\"rotate\", rotate);\n        telemetry.addData(\"First Angle\", angles.firstAngle);\n    }\n\n//    public void driveTo(Vector target, Vector currentPosition){ // Probably run this every few ticks\n//        displacement = target.add(currentPosition.multiply(-1)); // Normalize this when inputting for ratios\n//\n//        drive = RIGHT.multiply(displacement.normalize().get()[0])\n//                .add(BACKWARDS.multiply(displacement.normalize().get()[1]));\n//\n//        setPowers(MOTORS, drive);\n//    }\n\n    public static double sensitivity = 5.0; // \"Steepness\" of gradient vectors\n    public Vector correct(){\n        odometryAlg.updateOrientationAndLocation();\n        displacement.set(0, -sensitivity * ((currentPosition.get()[0] % 23.50) - 11.75));\n        displacement.set(1, -sensitivity * ((currentPosition.get()[1] % 23.50) - 11.75));\n\n        return translation.add(displacement);\n    }\n\n//    public void driveTo(double currentX, double currentY, double targetX, double targetY){ // Probably run this every few ticks\n//        displacement.set(0, targetX - currentX);\n//        displacement.set(1, targetY - currentY);\n//\n//        drive = RIGHT.multiply(displacement.normalize().get()[0])\n//                .add(BACKWARDS.multiply(displacement.normalize().get()[1]));\n//\n//        setPowers(MOTORS, drive);\n//    }\n\n    @Deprecated\n    public static void setVelocities(DcMotorEx [] motors, Vector vector){\n        for(int i = 0; i < vector.get().length; i++){\n            motors[i].setVelocity(vector.get()[i] * MAX);\n        }\n    }\n\n    public void setPowers(Vector vector, Telemetry telemetry){\n//        for(int i = 0; i < motors.length; i++){\n//            motors[i].setPower(vector.get()[i]);\n//            telemetry.addData(\"powa\", vector.get()[i]);\n//        }\n\n        FLMotor.setPower(vector.get()[0]);\n        FRMotor.setPower(vector.get()[1]);\n        BLMotor.setPower(vector.get()[2]);\n        BRMotor.setPower(vector.get()[3]);\n        telemetry.addData(\"powa\", vector.get()[0]);\n    }\n\n    public void telemetry(Telemetry telemetry) {\n        telemetry.addData(\"FR Motor Position\", FRMotor.getCurrentPosition());\n        telemetry.addData(\"FL Motor Position\", FLMotor.getCurrentPosition());\n        telemetry.addData(\"BR Motor Position\", BRMotor.getCurrentPosition());\n        telemetry.addData(\"BL Motor Position\", BLMotor.getCurrentPosition());\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java	(revision 63c7ed779f50fdc57ce89c510026183939f8d54d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drivetrain/MecanumDrive.java	(date 1666999522152)
@@ -39,7 +39,6 @@
     public static final double [] turnRight = {-1.0, -1.0, -1.0, -1.0};
     public Vector TURN_RIGHT = new Vector(turnRight);
 
-    public DcMotorEx [] MOTORS = {FLMotor, FRMotor, BLMotor, BRMotor};
 
     // Navigation
     public static final double [] NULL_POSITION = {0.0, 0.0};
@@ -103,8 +102,6 @@
 //        BLMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(1.00, 0.05, 0.0, 0.0));
 
 
-        MOTORS = new DcMotorEx[]{FLMotor, FRMotor, BLMotor, BRMotor};
-
         velocity = new Vector(NULL_POSITION);
         drive = new Vector(NULL);
         displacement = new Vector(new double [] {0.0, 0.0});
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/Master.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Add import statements as more data is added\n// Auxillary (driver hub, control hub, OD, etc...)\npackage org.firstinspires.ftc.teamcode.highlevel;\nimport com.qualcomm.hardware.bosch.BNO055IMU;\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\nimport com.qualcomm.robotcore.hardware.Gamepad;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\nimport org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\nimport org.firstinspires.ftc.teamcode.manipulator.DoubleReverse4Bar;\nimport org.firstinspires.ftc.teamcode.manipulator.LinearSlides;\nimport org.firstinspires.ftc.teamcode.manipulator.Turntable;\nimport org.firstinspires.ftc.teamcode.odometry.TestingOdometryAlgorithm;\nimport org.firstinspires.ftc.teamcode.drivetrain.*;\n\n// Encoders, Motors\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\n\n// Servos\n\n\n\n\n// Everything public except for in-class default values!!!!!!!!!\npublic class Master {\n    public static HardwareMap hardwaremap;\n\n    // Robot dimensions\n    final static double leftSensorPos = 7.5; // Probably change this to correct notation\n    final static double rightSensorPos = 7.5;\n    final static double backSensorPos = 7.5;\n    final static double robotLength = 15; // Change this to good notation pls\n    final static double robotWidth = 15;\n\n\n    // Driver hub and Vuforia\n    public static Telemetry telemetry;\n    private BNO055IMU IMU;\n    /* Can extract:\n    1. Absolute Orientation (Euler Vector, 100Hz) Three axis orientation data based on a 360° sphere\n\n    2. Absolute Orientation (Quaterion, 100Hz) Four point quaternion output for more accurate data manipulation\n\n    3. Angular Velocity Vector (100Hz) Three axis of 'rotation speed' in rad/s\n\n    4. Acceleration Vector (100Hz) Three axis of acceleration (gravity + linear motion) in m/s^2\n\n    5. Magnetic Field Strength Vector (20Hz) Three axis of magnetic field sensing in micro Tesla (uT)\n\n    6. Linear Acceleration Vector (100Hz) Three axis of linear acceleration data (acceleration minus gravity) in m/s^2\n\n    7. Gravity Vector (100Hz) Three axis of gravitational acceleration (minus any movement) in m/s^2\n\n    8. Temperature (1Hz) Ambient temperature in degrees celsius\n     */\n\n    // Odometry                             ________\n    public static DcMotorEx encoder1; //   |   ==   |\n    public static DcMotorEx encoder2; //   ||       |\n    public static DcMotorEx encoder3; //   |   ==   | encoder 1 on top, encoder 2 on bottom, encoder3 on left\n    //                                      ˜˜˜˜˜˜˜˜\n    public static Vector currentPosition;\n    public static Vector travel;\n    public static Vector orientation;\n    public static Vector normalOrientation;\n\n    // Calibration\n    public static DistanceSensor leftSensor;\n    public static DistanceSensor rightSensor;\n    public static DistanceSensor backSensor;\n\n    // Used to update encoder deltas\n    public static double encoder1Reading;\n    public static double encoder2Reading;\n    public static double encoder3Reading;\n\n    private static final double [] DEFAULT_POSITION = {0, 0}; // Get actual robot starting coordinates in inches on Friday, bottom left relative to our starting side is origin\n    // Probably write calibration method w/ tape and obj recognition\n    public static Vector STARTING_POSITION;\n    public static MecanumDrive drive;\n\n    // Manipulator\n    GridSystem grid;\n    public static Turntable turntable;\n    public static LinearSlides manipulator1;\n    public static DoubleReverse4Bar manipulator2;\n    public static double turntableAngle; // Radians, as always\n    public static TestingOdometryAlgorithm odometryAlg; // Add this\n\n\n    // Constructor to fully instantiate robot\n    public Master(){ // Lets finish this sometime lol\n        STARTING_POSITION = new Vector(DEFAULT_POSITION);\n\n\n        drive = new MecanumDrive(hardwaremap);\n        odometryAlg = new TestingOdometryAlgorithm(STARTING_POSITION);\n\n        manipulator1 = new LinearSlides();\n        manipulator2 = new DoubleReverse4Bar(hardwaremap);\n\n        leftSensor = hardwaremap.get(DistanceSensor.class, \"left calibration distance sensor\");\n        rightSensor = hardwaremap.get(DistanceSensor.class, \"right calibration distance sensor\");\n        backSensor = hardwaremap.get(DistanceSensor.class, \"back calibration distance sensor\");\n    }\n\n    public static double invSqrt(double x) { // Use this for inverse square root ig, gotta tell judges we used some innovative bit shift algorithm originally in C++ or smth\n        double xhalf = 0.5d * x;\n        long i = Double.doubleToLongBits(x);\n        i = 0x5fe6ec85e7de30daL - (i >> 1);\n        x = Double.longBitsToDouble(i);\n        x *= (1.5d - xhalf * x * x);\n        return x;\n    }\n\n    public static Vector calibratePosition(double currentOrientation, Vector currentPosition) {\n        double leftDistance = leftSensor.getDistance(DistanceUnit.INCH);\n        double rightDistance = rightSensor.getDistance(DistanceUnit.INCH);\n        double backDistance = backSensor.getDistance(DistanceUnit.INCH);\n\n        double x = -1; double y = -1;\n\n        if (currentOrientation > Math.PI/2 && currentOrientation < Math.PI) {\n            // if the back sensor reading is less than 24\n            if (backDistance < 24) {\n                // if back sensor is pointing to bottom wall\n                if ((backDistance + 7.5) * Math.sin(currentOrientation - Math.PI/2) < 144 - currentPosition.get()[0])\n                    y = (backDistance + 7.5) * Math.cos(currentOrientation - Math.PI/2);\n                    // if back sensor is pointing to right wall\n                else\n                    x = 144 - (backDistance + 7.5) * Math.cos(Math.PI-currentOrientation);\n            }\n            // if right sensor reading is less than 24\n            if (rightDistance < 24) {\n                // if right sensor is pointing to the right wall\n                if (x == -1 && (rightDistance + 7.5) * Math.sin(currentOrientation - Math.PI / 2) < 144 - currentPosition.get()[1])\n                    x = 144 - (rightDistance + 7.5) * Math.cos(currentOrientation - Math.PI / 2);\n                else if (y == -1)\n                    y = 144 - (rightDistance + 7.5) * Math.cos(Math.PI - currentOrientation);\n            }\n            // if left sensor reading is less than 24\n            if (leftDistance < 24) {\n                //if left sensor is pointing to bottom wall\n                if (y == -1 && (leftDistance + 7.5) * Math.sin(Math.PI - currentOrientation) < currentPosition.get()[0])\n                    y = (leftDistance + 7.5) * Math.cos(Math.PI - currentOrientation);\n                else if (x == -1)\n                    x = (leftDistance + 7.5) * Math.cos(currentOrientation - Math.PI/2);\n            }\n        }\n        else if (currentOrientation > Math.PI && currentOrientation < Math.PI * 3.0/2) {\n            // if back sensor reading is less than 24\n            if (backDistance < 24) {\n                // if back sensor is pointing to right wall\n                if ((backDistance + 7.5) * Math.sin(currentOrientation - Math.PI) < 144 - currentPosition.get()[1])\n                    x = 144 - (backDistance + 7.5) * Math.cos(currentOrientation - Math.PI);\n                    // if back sensor is pointing to top wall\n                else\n                    y = 144 - (backDistance + 7.5) * Math.cos(Math.PI * 3.0/2 - currentOrientation);\n            }\n            //right sensor reading is less than 24\n            if (rightDistance < 24) {\n                // if right sensor pointing to top wall\n                if (y == -1 && (rightDistance + 7.5) * Math.sin(currentOrientation - Math.PI) < currentPosition.get()[0])\n                    y = 144 - (rightDistance + 7.5) * Math.cos(currentOrientation - Math.PI);\n                    // if right sensor is pointing to left wall\n                else if (x == -1)\n                    x = (rightDistance + 7.5) * Math.cos(Math.PI * 3.0/2 - currentOrientation);\n            }\n            // if left sensor reading is less than 24\n            if (leftDistance < 24) {\n                // if left sensor is pointing to right wall\n                if (x == -1 && (leftDistance + 7.5) * Math.sin(Math.PI * 3.0/2 - currentOrientation) < currentPosition.get()[1])\n                    x = 144 - (leftDistance + 7.5) * Math.cos(Math.PI * 3.0/2 - currentOrientation);\n                    // if left sensor is pointing to bottom wall\n                else if (y == -1)\n                    y = (leftDistance + 7.5) * Math.cos(currentOrientation - Math.PI);\n            }\n        }\n        else if (currentOrientation > Math.PI * 3.0/2 && currentOrientation < Math.PI * 2) {\n            // if back sensor reading is less than 24\n            if (backDistance < 24) {\n                // if back sensor is pointing to top wall\n                if ((backDistance + 7.5) * Math.sin(currentOrientation - Math.PI * 3.0 / 2) < currentPosition.get()[0])\n                    y = 144 - (backDistance + 7.5) * Math.cos(currentOrientation - Math.PI * 3.0 / 2);\n                    // if back sensor is pointing to left wall\n                else\n                    x = (backDistance + 7.5) * Math.cos(2*Math.PI - currentOrientation);\n            }\n            // right distance reading is less than 24\n            if (rightDistance < 24) {\n                // if right sensor is pointing to left wall\n                if (x == -1 && (rightDistance + 7.5) * Math.sin(currentOrientation - Math.PI * 3.0/2) < currentPosition.get()[1])\n                    x = (rightDistance + 7.5) * Math.cos(currentOrientation - Math.PI);\n                    // if right sensor is pointing to bottom wall\n                else if (y == -1) {\n                    y = (rightDistance + 7.5) * Math.cos(2*Math.PI - currentOrientation);\n                }\n            }\n            // if left sensor reading is less than 24\n            if (leftDistance < 24) {\n                // if left sensor is pointing to top wall\n                if ( y == -1 && (leftDistance + 7.5) * Math.sin(2*Math.PI - currentOrientation) < 144 - currentPosition.get()[0])\n                    y = 144 - (leftDistance + 7.5) * Math.cos(2*Math.PI - currentOrientation);\n                    // if left sensor is pointing to right wall\n                else if (x == -1) {\n                    x = 144 - (leftDistance + 7.5) * Math.cos(currentOrientation - Math.PI * 3.0/2);\n                }\n            }\n        }\n        else {\n            // if back distance reading is less than 24\n            if (backDistance < 24) {\n                // if back sensor is pointing to left wall\n                if ((backDistance + 7.5) * Math.sin(currentOrientation) < currentPosition.get()[1])\n                    x = (backDistance + 7.5) * Math.cos(currentOrientation);\n                    // if back sensor is pointing to bottom wall\n                else\n                    y = (backDistance + 7.5) * Math.cos(Math.PI / 2 - currentOrientation);\n            }\n            // if right distance reading is less than 24\n            if (rightDistance < 24) {\n                // if right sensor is pointing to bottom wall\n                if (y == -1 && (rightDistance + 7.5) * Math.sin(currentOrientation) < 144 - currentPosition.get()[0])\n                    y = (rightDistance + 7.5) * Math.cos(currentOrientation);\n                    // if right sensor is pointing to right wall\n                else\n                    x = 144 - (rightDistance) * Math.cos(Math.PI/2 - currentOrientation);\n            }\n\n            // if left sensor reading is less than 24\n            if (leftDistance < 24) {\n                // if left sensor is pointing to left wall\n                if (x == -1 && (leftDistance + 7.5) * Math.sin(Math.PI/2 - currentOrientation) < 144 - currentPosition.get()[1])\n                    x = (backDistance + 7.5) * Math.cos(Math.PI/2 - currentOrientation);\n                // if left sensor is pointing to top wall\n                if (y == -1) {\n                    y = 144 - (leftDistance + 7.5) * Math.cos(currentOrientation);\n                }\n            }\n        }\n\n        return new Vector(new double[] {x, y});\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/Master.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/Master.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/Master.java	(revision 63c7ed779f50fdc57ce89c510026183939f8d54d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/highlevel/Master.java	(date 1666998906425)
@@ -77,7 +77,7 @@
     private static final double [] DEFAULT_POSITION = {0, 0}; // Get actual robot starting coordinates in inches on Friday, bottom left relative to our starting side is origin
     // Probably write calibration method w/ tape and obj recognition
     public static Vector STARTING_POSITION;
-    public static MecanumDrive drive;
+
 
     // Manipulator
     GridSystem grid;
@@ -89,11 +89,11 @@
 
 
     // Constructor to fully instantiate robot
-    public Master(){ // Lets finish this sometime lol
+    public Master(){
         STARTING_POSITION = new Vector(DEFAULT_POSITION);
 
 
-        drive = new MecanumDrive(hardwaremap);
+
         odometryAlg = new TestingOdometryAlgorithm(STARTING_POSITION);
 
         manipulator1 = new LinearSlides();
